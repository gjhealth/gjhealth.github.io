<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="高济科技">










<meta property="og:type" content="website">
<meta property="og:title" content="高济无线团队">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="高济无线团队">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="高济无线团队">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>高济无线团队</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">高济无线团队</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">求知若渴</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/04/Sketch基本操作/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/gaojihealth2.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高济无线团队">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/04/Sketch基本操作/" itemprop="url">Sketch基本操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-04T15:24:03+08:00">
                2019-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/文档/" itemprop="url" rel="index">
                    <span itemprop="name">文档</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/04/04/Sketch基本操作/" class="leancloud_visitors" data-flag-title="Sketch基本操作">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Sketch基本操作"><a href="#Sketch基本操作" class="headerlink" title="Sketch基本操作"></a>Sketch基本操作</h1><h2 id="1-Sketch介绍"><a href="#1-Sketch介绍" class="headerlink" title="1. Sketch介绍"></a>1. Sketch介绍</h2><p>Sketch是一款轻量，易用的矢量设计工具。Sketch 是一款适用于所有设计师的矢量绘图应用。矢量绘图也是目前进行网页，图标以及界面设计的最好方式。但除了矢量编辑的功能之外，我们同样添加了一些基本的位图工具，比如模糊和色彩校正。</p>
<h2 id="2-Sketch界面"><a href="#2-Sketch界面" class="headerlink" title="2. Sketch界面"></a>2. Sketch界面</h2><p> <img src="http://ww1.sinaimg.cn/large/820cdb69ly1fucioenx91j21400nadkh.jpg" alt="Sketch界面"></p>
<h2 id="3-插件"><a href="#3-插件" class="headerlink" title="3. 插件"></a>3. 插件</h2><p> <a href="http://www.sketchcn.com/sketch-tips-tricks-1.html" target="_blank" rel="noopener">Sketch 插件大集合</a></p>
<h2 id="4-常用功能介绍"><a href="#4-常用功能介绍" class="headerlink" title="4. 常用功能介绍"></a>4. 常用功能介绍</h2><p><a href="http://www.sketchcn.com/sketch-chinese-user-manual.html" target="_blank" rel="noopener">中文用户手册</a></p>
<h2 id="5-快速上手视频"><a href="#5-快速上手视频" class="headerlink" title="5. 快速上手视频"></a>5. 快速上手视频</h2><p><a href="http://www.ui.cn/detail/228225.html" target="_blank" rel="noopener">快速上手教程</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/04/创建CocoaPods私有仓库/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/gaojihealth2.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高济无线团队">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/04/创建CocoaPods私有仓库/" itemprop="url">创建CocoaPods私有仓库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-04T15:15:36+08:00">
                2019-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/文档/" itemprop="url" rel="index">
                    <span itemprop="name">文档</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/04/04/创建CocoaPods私有仓库/" class="leancloud_visitors" data-flag-title="创建CocoaPods私有仓库">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="创建CocoaPods私有仓库"><a href="#创建CocoaPods私有仓库" class="headerlink" title="创建CocoaPods私有仓库"></a>创建CocoaPods私有仓库</h1><ol>
<li><p>创建版本库（<em>用于存放版本</em>）</p>
<ul>
<li>从Git服务器创建一个私有仓库</li>
</ul>
<p><img src="https://i.loli.net/2019/04/03/5ca44bfeee983.png" alt="创建版本库"></p>
<ul>
<li><p>打开终端输入代码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pod repo add GJRepo https://github.com/gjhealth/GJRepo.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看目录 <code>~/.cocoapods/repos</code> 显示如下图，除master之外会增加一个版本仓库</p>
<p><img src="https://i.loli.net/2019/04/03/5ca44f78bf4da.png" alt="repos目录"></p>
</li>
</ul>
</li>
<li><p>创建私有代码仓库（<em>用于存放自定义控件</em>）</p>
<ul>
<li><p>创建仓库同时勾选 <code>MIT License</code> 和 <code>README</code></p>
<p><img src="https://i.loli.net/2019/04/03/5ca452760e36a.png" alt="自定义组件库"></p>
</li>
<li><p>克隆项目到本地并添加文件<code>代码</code>、<code>仓库名.podspec</code>、<code>.swift-version</code></p>
<p><img src="https://i.loli.net/2019/04/03/5ca453862b555.png" alt="文件目录"></p>
<blockquote>
<p><code>.swift-version</code>文件用来指导swift版本</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> echo "3.0" &gt; .swift-version</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>.podspec</code>代码库pod描述文件，可以通过指令创建空白模板</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pod spec create MyLib</span><br></pre></td></tr></table></figure>
<p>或者拷贝下面模板进行修改</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">  s.name         = "MyAdditions" # 项目名称</span><br><span class="line">  s.version      = "0.0.1"        # 版本号 与 你仓库的 标签号 对应</span><br><span class="line">  s.license      = "MIT"          # 开源证书</span><br><span class="line">  s.summary      = "私人pod代码" # 项目简介</span><br><span class="line"></span><br><span class="line">  s.homepage     = "https://git.oschina.net/baiyingqiu/MyAdditions" # 仓库的主页</span><br><span class="line">  s.source       = &#123; :git =&gt; "https://git.oschina.net/baiyingqiu/MyAdditions.git", :tag =&gt; "#&#123;s.version&#125;" &#125;#你的仓库地址，不能用SSH地址</span><br><span class="line">  s.source_files = "MyAdditions/*.&#123;h,m&#125;" # 你代码的位置， BYPhoneNumTF/*.&#123;h,m&#125; 表示 BYPhoneNumTF 文件夹下所有的.h和.m文件</span><br><span class="line">  s.requires_arc = true # 是否启用ARC</span><br><span class="line">  s.platform     = :ios, "7.0" #平台及支持的最低版本</span><br><span class="line">  # s.frameworks   = "UIKit", "Foundation" #支持的框架</span><br><span class="line">  # s.dependency   = "AFNetworking" # 依赖库</span><br><span class="line"></span><br><span class="line">  # User</span><br><span class="line">  s.author             = &#123; "BY" =&gt; "qiubaiyingios@163.com" &#125; # 作者信息</span><br><span class="line">  s.social_media_url   = "http://qiubaiying.github.io" # 个人主页</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>验证仓库是否正确</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pod lib lint</span><br></pre></td></tr></table></figure>
<blockquote>
<p>验证并没问题后添加<code>--allow-warnings</code>就可以通过验证了</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pod lib lint --allow-warnings</span><br></pre></td></tr></table></figure>
<blockquote>
<p>验证后显示</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> MyAdditions (0.0.1)</span><br><span class="line">     </span><br><span class="line">MyAdditions passed validation.</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>将描述文件推送到版本库</p>
<ul>
<li><p>将项目打标签并推送到远程仓库，标签号和版本号对应。然后将代码仓库描述信息push到版本仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod repo push MyRepo GJLib.podspec --allow-warnings</span><br></pre></td></tr></table></figure>
<p>当验证成功后<code>~/.cocoapods/repos/MyRep</code>目录下回新增仓库的描述信息</p>
<p><img src="https://i.loli.net/2019/04/03/5ca4673f2cd1a.png" alt="repos目录"></p>
</li>
</ul>
</li>
<li><p>私有pod库的使用</p>
<ul>
<li><p>编辑<code>Podfile</code>添加私有版本库和公有库地址，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">source ‘https://github.com/CocoaPods/Specs.git’</span><br><span class="line">source ‘https://git.oschina.net/baiyingqiu/MyRepo.git’</span><br><span class="line"></span><br><span class="line">platform :ios, &apos;8.0&apos;</span><br><span class="line"></span><br><span class="line">target ‘MyPodTest’ do</span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">pod “BYPhoneNumTF” #公有库</span><br><span class="line">pod ‘GJLib’ #我们的私有库</span><br><span class="line">pod ‘GJTest’ #这是我又添加到版本库中的另一个代码库</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行<code>pod install</code></p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>参考文章</strong>：</p>
<p><a href="https://www.jianshu.com/p/0c640821b36f" target="_blank" rel="noopener">https://www.jianshu.com/p/0c640821b36f</a></p>
<p><a href="https://blog.csdn.net/qq_19957803/article/details/78656688" target="_blank" rel="noopener">https://blog.csdn.net/qq_19957803/article/details/78656688</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/01/React-基础教程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/gaojihealth2.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高济无线团队">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/01/React-基础教程/" itemprop="url">React-基础教程I</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-01T15:28:39+08:00">
                2019-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/04/01/React-基础教程/" class="leancloud_visitors" data-flag-title="React-基础教程I">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;h1&gt;Hello, world!&lt;/h1&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="JSX-简介"><a href="#JSX-简介" class="headerlink" title="JSX 简介"></a>JSX 简介</h2><p>   考虑如下变量声明：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</span><br></pre></td></tr></table></figure></p>
<p>   这个有趣的标签语法既不是字符串也不是 HTML。</p>
<p>   它被称为 JSX，是一个 JavaScript 的语法扩展。我们建议在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。</p>
<p>   JSX 可以生成 React “元素”。我们将在下一章节中探讨如何将这些元素渲染为 DOM。下面我们看下学习 JSX 所需的基础知识。</p>
<p>   为什么使用 JSX？<br>   React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据。</p>
<p>   React 并没有采用将标记与逻辑进行分离到不同文件这种人为地分离方式，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中，来实现关注点分离。我们将在后面章节中深入学习组件。如果你还没有适应在 JS 中使用标记语言，这个会议讨论应该可以说服你。</p>
<p>   React 不强制要求使用 JSX，但是大多数人发现，在 JavaScript 代码中将 JSX 和 UI 放在一起时，会在视觉上有辅助作用。它还可以使 React 显示更多有用的错误和警告消息。</p>
<p>   搞清楚这个问题后，我们就开始学习 JSX 吧！</p>
<p>   在 JSX 中嵌入表达式<br>   在下面的例子中，我们声明了一个名为 name 的变量，然后在 JSX 中使用它，并将它包裹在大括号中：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const name = &apos;Josh Perez&apos;;</span><br><span class="line">const element = &lt;h1&gt;Hello, &#123;name&#125;&lt;/h1&gt;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br><span class="line">在 JSX 语法中，你可以在大括号内放置任何有效的 JavaScript 表达式。例如，2 + 2，user.firstName 或 formatName(user) 都是有效的 JavaScript 表达式。</span><br><span class="line"></span><br><span class="line">在下面的示例中，我们将调用 JavaScript 函数 formatName(user) 的结果，并将结果嵌入到 &lt;h1&gt; 元素中。</span><br><span class="line"></span><br><span class="line">function formatName(user) &#123;</span><br><span class="line">  return user.firstName + &apos; &apos; + user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const user = &#123;</span><br><span class="line">  firstName: &apos;Harper&apos;,</span><br><span class="line">  lastName: &apos;Perez&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const element = (</span><br><span class="line">  &lt;h1&gt;</span><br><span class="line">    Hello, &#123;formatName(user)&#125;!</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>   在 CodePen 上尝试</p>
<p>   为了便于阅读，我们会将 JSX 拆分为多行。同时，我们建议将内容包裹在括号中，虽然这样做不是强制要求的，但是这可以避免遇到自动插入分号陷阱。</p>
<p>   JSX 也是一个表达式<br>   在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。</p>
<p>   也就是说，你可以在 if 语句和 for 循环的代码块中使用 JSX，将 JSX 赋值给变量，把 JSX 当作参数传入，以及从函数中返回 JSX：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getGreeting(user) &#123;</span><br><span class="line">  if (user) &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>   JSX 特定属性<br>   你可以通过使用引号，来将属性值指定为字符串字面量：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;;</span><br></pre></td></tr></table></figure></p>
<p>   也可以使用大括号，来在属性值中插入一个 JavaScript 表达式：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;img src=&#123;user.avatarUrl&#125;&gt;&lt;/img&gt;;</span><br></pre></td></tr></table></figure></p>
<p>   在属性中嵌入 JavaScript 表达式时，不要在大括号外面加上引号。你应该仅使用引号（对于字符串值）或大括号（对于表达式）中的一个，对于同一属性不能同时使用这两种符号。</p>
<p>   警告：</p>
<p>   因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 camelCase（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。</p>
<p>   例如，JSX 里的 class 变成了 className，而 tabindex 则变为 tabIndex。</p>
<p>   使用 JSX 指定子元素<br>   假如一个标签里面没有内容，你可以使用 /&gt; 来闭合标签，就像 XML 语法一样：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;img src=&#123;user.avatarUrl&#125; /&gt;;</span><br><span class="line">JSX 标签里能够包含很多子元素:</span><br><span class="line"></span><br><span class="line">const element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;Good to see you here.&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">JSX 防止注入攻击</span><br><span class="line">你可以安全地在 JSX 当中插入用户输入内容：</span><br><span class="line"></span><br><span class="line">const title = response.potentiallyMaliciousInput;</span><br><span class="line">// 直接使用是安全的：</span><br><span class="line">const element = &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;;</span><br><span class="line">React DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。</span><br><span class="line"></span><br><span class="line">JSX 表示对象</span><br><span class="line">Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。</span><br><span class="line"></span><br><span class="line">以下两种示例代码完全等效：</span><br><span class="line"></span><br><span class="line">const element = (</span><br><span class="line">  &lt;h1 className=&quot;greeting&quot;&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">);</span><br><span class="line">const element = React.createElement(</span><br><span class="line">  &apos;h1&apos;,</span><br><span class="line">  &#123;className: &apos;greeting&apos;&#125;,</span><br><span class="line">  &apos;Hello, world!&apos;</span><br><span class="line">);</span><br><span class="line">React.createElement() 会预先执行一些检查，以帮助你编写无错代码，但实际上它创建了一个这样的对象：</span><br><span class="line"></span><br><span class="line">// 注意：这是简化过的结构</span><br><span class="line">const element = &#123;</span><br><span class="line">  type: &apos;h1&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: &apos;greeting&apos;,</span><br><span class="line">    children: &apos;Hello, world!&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>   这些对象被称为 “React 元素”。它们描述了你希望在屏幕上看到的内容。React 通过读取这些对象，然后使用它们来构建 DOM 以及保持随时更新。</p>
<h2 id="React-元素渲染"><a href="#React-元素渲染" class="headerlink" title="React 元素渲染"></a>React 元素渲染</h2><pre><code>元素是构成 React 应用的最小砖块。

元素描述了你在屏幕上想看到的内容。

const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;
与浏览器的 DOM 元素不同，React 元素是创建开销极小的普通对象。React DOM 会负责更新 DOM 来与 React 元素保持一致。

注意：

你可能会将元素与另一个被熟知的概念——“组件”混淆起来。我们会在下一个章节介绍组件。组件是由元素构成的。我们强烈建议你不要觉得繁琐而跳过本章节，应当深入阅读这一章节。

将一个元素渲染为 DOM
假设你的 HTML 文件某处有一个 &lt;div&gt;：

&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
我们将其称为“根” DOM 节点，因为该节点内的所有内容都将由 React DOM 管理。

仅使用 React 构建的应用通常只有单一的根 DOM 节点。如果你在将 React 集成进一个已有应用，那么你可以在应用中包含任意多的独立根 DOM 节点。

想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 ReactDOM.render()：

const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;
ReactDOM.render(element, document.getElementById(&apos;root&apos;));
Try it on CodePen

页面上会展示出 “Hello, world”。
</code></pre><h2 id="组件-amp-Props"><a href="#组件-amp-Props" class="headerlink" title="组件 &amp; Props"></a>组件 &amp; Props</h2><pre><code>组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。本指南旨在介绍组件的相关理念。你可以参考详细组件 API。

组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。

函数组件与 class 组件
定义组件最简单的方式就是编写 JavaScript 函数：

function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}
该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。

你同时还可以使用 ES6 的 class 来定义组件：

class Welcome extends React.Component {
  render() {
    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;
  }
}
上述两个组件在 React 里是等效的。

我们将在下一章节中讨论关于 class 的额外特性。在那之前，为了保持示例简单明了，将使用函数组件。

渲染组件
之前，我们遇到的 React 元素都只是 DOM 标签：

const element = &lt;div /&gt;;
不过，React 元素也可以是用户自定义的组件：

const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;
当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）转换为单个对象传递给组件，这个对象被称之为 “props”。

例如，这段代码会在页面上渲染 “Hello, Sara”：

function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}

const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;
ReactDOM.render(
  element,
  document.getElementById(&apos;root&apos;)
);
在 CodePen 上尝试

让我们来回顾一下这个例子中发生了什么：

我们调用 ReactDOM.render() 函数，并传入 &lt;Welcome name=&quot;Sara&quot; /&gt; 作为参数。
React 调用 Welcome 组件，并将 {name: &apos;Sara&apos;} 作为 props 传入。
Welcome 组件将 &lt;h1&gt;Hello, Sara&lt;/h1&gt; 元素作为返回值。
React DOM 将 DOM 高效地更新为 &lt;h1&gt;Hello, Sara&lt;/h1&gt;。
注意： 组件名称必须以大写字母开头。

React 会将以小写字母开头的组件视为原生 DOM 标签。例如，&lt;div /&gt; 代表 HTML 的 div 标签，而 &lt;Welcome /&gt; 则代表一个组件，并且需在作用域内使用 Welcome。

你可以在深入 JSX中了解更多关于此规范的原因。

组合组件
组件可以在其输出中引用其他组件。这就可以让我们用同一组件来抽象出任意层次的细节。按钮，表单，对话框，甚至整个屏幕的内容：在 React 应用程序中，这些通常都会以组件的形式表示。

例如，我们可以创建一个可以多次渲染 Welcome 组件的 App 组件：

function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}

function App() {
  return (
    &lt;div&gt;
      &lt;Welcome name=&quot;Sara&quot; /&gt;
      &lt;Welcome name=&quot;Cahal&quot; /&gt;
      &lt;Welcome name=&quot;Edite&quot; /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(
  &lt;App /&gt;,
  document.getElementById(&apos;root&apos;)
);
在 CodePen 上尝试

通常来说，每个新的 React 应用程序的顶层组件都是 App 组件。但是，如果你将 React 集成到现有的应用程序中，你可能需要使用像 Button 这样的小组件，并自下而上地将这类组件逐步应用到视图层的每一处。

提取组件
将组件拆分为更小的组件。

例如，参考如下 Comment 组件：

function Comment(props) {
  return (
    &lt;div className=&quot;Comment&quot;&gt;
      &lt;div className=&quot;UserInfo&quot;&gt;
        &lt;img className=&quot;Avatar&quot;
          src={props.author.avatarUrl}
          alt={props.author.name}
        /&gt;
        &lt;div className=&quot;UserInfo-name&quot;&gt;
          {props.author.name}
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div className=&quot;Comment-text&quot;&gt;
        {props.text}
      &lt;/div&gt;
      &lt;div className=&quot;Comment-date&quot;&gt;
        {formatDate(props.date)}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
在 CodePen 上尝试

该组件用于描述一个社交媒体网站上的评论功能，它接收 author（对象），text （字符串）以及 date（日期）作为 props。

该组件由于嵌套的关系，变得难以维护，且很难复用它的各个部分。因此，让我们从中提取一些组件出来。

首先，我们将提取 Avatar 组件：

function Avatar(props) {
  return (
    &lt;img className=&quot;Avatar&quot;
      src={props.user.avatarUrl}
      alt={props.user.name}
    /&gt;

  );
}
Avatar 不需知道它在 Comment 组件内部是如何渲染的。因此，我们给它的 props 起了一个更通用的名字：user，而不是 author。

我们建议从组件自身的角度命名 props，而不是依赖于调用组件的上下文命名。

我们现在针对 Comment 做些微小调整：

function Comment(props) {
  return (
    &lt;div className=&quot;Comment&quot;&gt;
      &lt;div className=&quot;UserInfo&quot;&gt;
        &lt;Avatar user={props.author} /&gt;
        &lt;div className=&quot;UserInfo-name&quot;&gt;
          {props.author.name}
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div className=&quot;Comment-text&quot;&gt;
        {props.text}
      &lt;/div&gt;
      &lt;div className=&quot;Comment-date&quot;&gt;
        {formatDate(props.date)}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
接下来，我们将提取 UserInfo 组件，该组件在用户名旁渲染 Avatar 组件：

function UserInfo(props) {
  return (
    &lt;div className=&quot;UserInfo&quot;&gt;
      &lt;Avatar user={props.user} /&gt;
      &lt;div className=&quot;UserInfo-name&quot;&gt;
        {props.user.name}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
进一步简化 Comment 组件：

function Comment(props) {
  return (
    &lt;div className=&quot;Comment&quot;&gt;
      &lt;UserInfo user={props.author} /&gt;
      &lt;div className=&quot;Comment-text&quot;&gt;
        {props.text}
      &lt;/div&gt;
      &lt;div className=&quot;Comment-date&quot;&gt;
        {formatDate(props.date)}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
在 CodePen 上尝试

最初看上去，提取组件可能是一件繁重的工作，但是，在大型应用中，构建可复用组件库是完全值得的。根据经验来看，如果 UI 中有一部分被多次使用（Button，Panel，Avatar），或者组件本身就足够复杂（App，FeedStory，Comment），那么它就是一个可复用组件的候选项。
</code></pre><h2 id="State-amp-生命周期"><a href="#State-amp-生命周期" class="headerlink" title="State &amp; 生命周期"></a>State &amp; 生命周期</h2><pre><code>本页面介绍了 React 组件中 state 和生命周期的概念。你可以查阅详细的组件 API 参考文档。

请参考前一章节中时钟的例子。在元素渲染章节中，我们只了解了一种更新 UI 界面的方法。通过调用 ReactDOM.render() 来修改我们想要渲染的元素：

function tick() {
  const element = (
    &lt;div&gt;
      &lt;h1&gt;Hello, world!&lt;/h1&gt;
      &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;
    &lt;/div&gt;
  );
  ReactDOM.render(
    element,
    document.getElementById(&apos;root&apos;)
  );
}

setInterval(tick, 1000);
在 CodePen 上尝试

在本章节中，我们将学习如何封装真正可复用的 Clock 组件。它将设置自己的计时器并每秒更新一次。

我们可以从封装时钟的外观开始：

function Clock(props) {
  return (
    &lt;div&gt;
      &lt;h1&gt;Hello, world!&lt;/h1&gt;
      &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;
    &lt;/div&gt;
  );
}

function tick() {
  ReactDOM.render(
    &lt;Clock date={new Date()} /&gt;,
    document.getElementById(&apos;root&apos;)
  );
}

setInterval(tick, 1000);
在 CodePen 上尝试

然而，它忽略了一个关键的技术细节：Clock 组件需要设置一个计时器，并且需要每秒更新 UI。

理想情况下，我们希望只编写一次代码，便可以让 Clock 组件自我更新：

ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById(&apos;root&apos;)
);
我们需要在 Clock 组件中添加 “state” 来实现这个功能。

State 与 props 类似，但是 state 是私有的，并且完全受控于当前组件。

将函数组件转换成 class 组件
通过以下五步将 Clock 的函数组件转成 class 组件：

创建一个同名的 ES6 class，并且继承于 React.Component。

添加一个空的 render() 方法。

将函数体移动到 render() 方法之中。

在 render() 方法中使用 this.props 替换 props。

删除剩余的空函数声明。

class Clock extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.props.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}
在 CodePen 上尝试

现在 Clock 组件被定义为 class，而不是函数。

每次组件更新时 render 方法都会被调用，但只要在相同的 DOM 节点中渲染 &lt;Clock /&gt; ，就仅有一个 Clock 组件的 class 实例被创建使用。这就使得我们可以使用如 state 或生命周期方法等很多其他特性。

向 class 组件中添加局部的 state
我们通过以下三步将 date 从 props 移动到 state 中：

把 render() 方法中的 this.props.date 替换成 this.state.date ：
class Clock extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}
添加一个 class 构造函数，然后在该函数中为 this.state 赋初值：
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}
通过以下方式将 props 传递到父类的构造函数中：

  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }
Class 组件应该始终使用 props 参数来调用父类的构造函数。

移除 &lt;Clock /&gt; 元素中的 date 属性：
ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById(&apos;root&apos;)
);
我们之后会将计时器相关的代码添加到组件中。

代码如下：

class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById(&apos;root&apos;)
);
在 CodePen 上尝试

接下来，我们会设置 Clock 的计时器并每秒更新它。

将生命周期方法添加到 Class 中
在具有许多组件的应用程序中，当组件被销毁时释放所占用的资源是非常重要的。

当 Clock 组件第一次被渲染到 DOM 中的时候，就为其设置一个计时器。这在 React 中被称为“挂载（mount）”。

同时，当 DOM 中 Clock 组件被删除的时候，应该清除计时器。这在 React 中被称为“卸载（umount）”。

我们可以为 class 组件声明一些特殊的方法，当组件挂载或卸载时就会去执行这些方法：

class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {

  }

  componentWillUnmount() {

  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}
这些方法叫做“生命周期方法”。

componentDidMount() 方法会在组件已经被渲染到 DOM 中后运行，所以，最好在这里设置计时器：

  componentDidMount() {
    this.timerID = setInterval(
      () =&gt; this.tick(),
      1000
    );
  }
接下来把计时器的 ID 保存在 this 之中。

尽管 this.props 和 this.state 是 React 本身设置的，且都拥有特殊的含义，但是其实你可以向 class 中随意添加不参与数据流（比如计时器 ID）的额外字段。

我们会在 componentWillUnmount() 生命周期方法中清除计时器：

  componentWillUnmount() {
    clearInterval(this.timerID);
  }
最后，我们会实现一个叫 tick()　的方法，Clock 组件每秒都会调用它。

使用 this.setState() 来时刻更新组件 state：

class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {
    this.timerID = setInterval(
      () =&gt; this.tick(),
      1000
    );
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    this.setState({
      date: new Date()
    });
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById(&apos;root&apos;)
);
在 CodePen 上尝试

现在时钟每秒都会刷新。

让我们来快速概括一下发生了什么和这些方法的调用顺序：

当 &lt;Clock /&gt; 被传给 ReactDOM.render()的时候，React 会调用 Clock 组件的构造函数。 因为 Clock 需要显示当前的时间，所以它会用一个包含当前时间的对象来初始化 this.state。我们会在之后更新 state。

之后 React 会调用组件的 render() 方法。这就是　React 确定该在页面上展示什么的方式。然后　React 更新 DOM 来匹配 Clock 渲染的输出。

当 Clock 的输出被插入到 DOM 中后， React 就会调用 ComponentDidMount() 生命周期方法。在这个方法中，Clock 组件向浏览器请求设置一个计时器来每秒调用一次组件的 tick() 方法。

浏览器每秒都会调用一次 tick() 方法。 在这方法之中，Clock 组件会通过调用 setState() 来计划进行一次 UI 更新。得益于 setState() 的调用，React 能够知道 state 已经改变了，然后会重新调用 render() 方法来确定页面上该显示什么。这一次，render() 方法中的 this.state.date 就不一样了，如此以来就会渲染输出更新过的时间。React 也会相应的更新 DOM。

一旦 Clock 组件从 DOM 中被移除，React 就会调用 componentWillUnmount() 生命周期方法，这样计时器就停止了。

正确地使用 State
关于 setState() 你应该了解三件事：

不要直接修改 State
例如，此代码不会重新渲染组件：

// Wrong
this.state.comment = &apos;Hello&apos;;
而是应该使用 setState():

// Correct
this.setState({comment: &apos;Hello&apos;});
构造函数是唯一可以给 this.state 赋值的地方：

State 的更新可能是异步的
出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。

因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。

例如，此代码可能会无法更新计数器：

// Wrong
this.setState({
  counter: this.state.counter + this.props.increment,
});
要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：

// Correct
this.setState((state, props) =&gt; ({
  counter: state.counter + props.increment
}));
上面使用了箭头函数，不过使用普通的函数也同样可以：

// Correct
this.setState(function(state, props) {
  return {
    counter: state.counter + props.increment
  };
});
State 的更新会被合并
当你调用 setState() 的时候，React 会把你提供的对象合并到当前的 state。

例如，你的 state 包含几个独立的变量：

  constructor(props) {
    super(props);
    this.state = {
      posts: [],
      comments: []
    };
  }
然后你可以分别调用 setState() 来单独地更新它们：

  componentDidMount() {
    fetchPosts().then(response =&gt; {
      this.setState({
        posts: response.posts
      });
    });

    fetchComments().then(response =&gt; {
      this.setState({
        comments: response.comments
      });
    });
  }
这里的合并是浅合并，所以 this.setState({comments}) 完整保留了 this.state.posts， 但是完全替换了 this.state.comments。

数据是向下流动的
不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。

这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。

组件可以选择把它的 state 作为 props 向下传递到它的子组件中：

&lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
这对于自定义组件同样适用：

&lt;FormattedDate date={this.state.date} /&gt;
FormattedDate 组件会在其 props 中接收参数 date，但是组件本身无法知道它是来自于 Clock 的 state，或是 Clock 的 props，还是手动输入的：

function FormattedDate(props) {
  return &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;;
}
在 CodePen 上尝试

这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。

如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。

为了证明每个组件都是真正独立的，我们可以创建一个渲染三个 Clock 的 App 组件：

function App() {
  return (
    &lt;div&gt;
      &lt;Clock /&gt;
      &lt;Clock /&gt;
      &lt;Clock /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(
  &lt;App /&gt;,
  document.getElementById(&apos;root&apos;)
);
在 CodePen 上尝试

每个 Clock 组件都会单独设置它自己的计时器并且更新它。

在 React 应用中，组件是有状态组件还是无状态组件属于组件实现的细节，它可能会随着时间的推移而改变。你可以在有状态的组件中使用无状态的组件，反之亦然。
</code></pre><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><pre><code>React 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同:

React 事件的命名采用小驼峰式（camelCase），而不是纯小写。
使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。
例如，传统的 HTML：

&lt;button onclick=&quot;activateLasers()&quot;&gt;
  Activate Lasers
&lt;/button&gt;
在 React 中略微不同：

&lt;button onClick={activateLasers}&gt;
  Activate Lasers
&lt;/button&gt;
在 React 中另一个不同点是你不能通过返回 false 的方式阻止默认行为。你必须显式的使用 preventDefault 。例如，传统的 HTML 中阻止链接默认打开一个新页面，你可以这样写：

&lt;a href=&quot;#&quot; onclick=&quot;console.log(&apos;The link was clicked.&apos;); return false&quot;&gt;
  Click me
&lt;/a&gt;
在 React 中，可能是这样的：

function ActionLink() {
  function handleClick(e) {
    e.preventDefault();
    console.log(&apos;The link was clicked.&apos;);
  }

  return (
    &lt;a href=&quot;#&quot; onClick={handleClick}&gt;
      Click me
    &lt;/a&gt;
  );
}
在这里，e 是一个合成事件。React 根据 W3C 规范来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。如果想了解更多，请查看 SyntheticEvent 参考指南。

使用 React 时，你一般不需要使用 addEventListener 为已创建的 DOM 元素添加监听器。React恰恰与之相反，你仅需要在该元素初始渲染的时候添加一个监听器。

当你使用 ES6 class 语法定义一个组件的时候，通常的做法是将事件处理函数声明为 class 中的方法。例如，下面的 Toggle 组件会渲染一个让用户切换开关状态的按钮：

class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};

    // 为了在回调中使用 `this`，这个绑定是必不可少的
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState(state =&gt; ({
      isToggleOn: !state.isToggleOn
    }));
  }

  render() {
    return (
      &lt;button onClick={this.handleClick}&gt;
        {this.state.isToggleOn ? &apos;ON&apos; : &apos;OFF&apos;}
      &lt;/button&gt;
    );
  }
}

ReactDOM.render(
  &lt;Toggle /&gt;,
  document.getElementById(&apos;root&apos;)
);
在 CodePen 上尝试

你必须谨慎对待 JSX 回调函数中的 this，在 JavaScript 中，class 的方法默认不会绑定 this。如果你忘记绑定 this.handleClick 并把它传入了 onClick，当你调用这个函数的时候 this 的值为 undefined。

这并不是 React 特有的行为；这其实与 JavaScript 函数工作原理有关。通常情况下，如果你没有在方法后面添加 ()，例如 onClick={this.handleClick}，你应该为这个方法绑定 this。

如果觉得使用 bind 很麻烦，这里有两种方式可以解决。如果你正在使用实验性的 public class fields 语法，你可以使用 class fileds 正确的绑定回调函数：

class LoggingButton extends React.Component {
  // 此语法确保 `handleClick` 内的 `this` 已被绑定。
  // 注意: 这是 *实验性* 语法。
  handleClick = () =&gt; {
    console.log(&apos;this is:&apos;, this);
  }

  render() {
    return (
      &lt;button onClick={this.handleClick}&gt;
        Click me
      &lt;/button&gt;
    );
  }
}
Create React App 默认启用此语法。

如果你没有使用 class fileds 语法，你可以在回调中使用箭头函数：

class LoggingButton extends React.Component {
  handleClick() {
    console.log(&apos;this is:&apos;, this);
  }

  render() {
    // 此语法确保 `handleClick` 内的 `this` 已被绑定。
    return (
      &lt;button onClick={(e) =&gt; this.handleClick(e)}&gt;
        Click me
      &lt;/button&gt;
    );
  }
}
此语法问题在于每次渲染 LoggingButton 时都会创建不同的回调函数。在大多数情况下，这没什么问题，但如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染。我们通常建议在构造器中绑定或使用 class fileds 语法来避免这类性能问题。
</code></pre><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><pre><code>在 React 中，你可以创建不同的组件来封装各种你需要的行为。然后，依据应用的不同状态，你可以只渲染对应状态下的部分内容。

React 中的条件渲染和 JavaScript 中的一样，使用 JavaScript 运算符 if 或者条件运算符去创建元素来表现当前的状态，然后让 React 根据它们来更新 UI。

观察这两个组件:

function UserGreeting(props) {
  return &lt;h1&gt;Welcome back!&lt;/h1&gt;;
}

function GuestGreeting(props) {
  return &lt;h1&gt;Please sign up.&lt;/h1&gt;;
}
再创建一个 Greeting 组件，它会根据用户是否登录来决定显示上面的哪一个组件。

function Greeting(props) {
  const isLoggedIn = props.isLoggedIn;
  if (isLoggedIn) {
    return &lt;UserGreeting /&gt;;
  }
  return &lt;GuestGreeting /&gt;;
}

ReactDOM.render(
  // Try changing to isLoggedIn={true}:
  &lt;Greeting isLoggedIn={false} /&gt;,
  document.getElementById(&apos;root&apos;)
);
在 CodePen 上尝试

这个示例根据 isLoggedIn 的值来渲染不同的问候语。

元素变量
你可以使用变量来储存元素。 它可以帮助你有条件地渲染组件的一部分，而其他的渲染部分并不会因此而改变。

观察这两个组件，它们分别代表了注销和登录按钮：

function LoginButton(props) {
  return (
    &lt;button onClick={props.onClick}&gt;
      Login
    &lt;/button&gt;
  );
}

function LogoutButton(props) {
  return (
    &lt;button onClick={props.onClick}&gt;
      Logout
    &lt;/button&gt;
  );
}
在下面的示例中，我们将创建一个名叫 LoginControl 的有状态的组件。

它将根据当前的状态来渲染 &lt;LoginButton /&gt; 或者 &lt;LogoutButton /&gt;。同时它还会渲染上一个示例中的 &lt;Greeting /&gt;。

class LoginControl extends React.Component {
  constructor(props) {
    super(props);
    this.handleLoginClick = this.handleLoginClick.bind(this);
    this.handleLogoutClick = this.handleLogoutClick.bind(this);
    this.state = {isLoggedIn: false};
  }

  handleLoginClick() {
    this.setState({isLoggedIn: true});
  }

  handleLogoutClick() {
    this.setState({isLoggedIn: false});
  }

  render() {
    const isLoggedIn = this.state.isLoggedIn;
    let button;

    if (isLoggedIn) {
      button = &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;;
    } else {
      button = &lt;LoginButton onClick={this.handleLoginClick} /&gt;;
    }

    return (
      &lt;div&gt;
        &lt;Greeting isLoggedIn={isLoggedIn} /&gt;
        {button}
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;LoginControl /&gt;,
  document.getElementById(&apos;root&apos;)
);
在 CodePen 上尝试

声明一个变量并使用 if 语句进行条件渲染是不错的方式，但有时你可能会想使用更为简洁的语法。接下来，我们将介绍几种在 JSX 中内联条件渲染的方法。

与运算符 &amp;&amp;
通过花括号包裹代码，你可以在 JSX 中嵌入任何表达式。这也包括 JavaScript 中的逻辑与 (&amp;&amp;) 运算符。它可以很方便地进行元素的条件渲染。

function Mailbox(props) {
  const unreadMessages = props.unreadMessages;
  return (
    &lt;div&gt;
      &lt;h1&gt;Hello!&lt;/h1&gt;
      {unreadMessages.length &gt; 0 &amp;&amp;
        &lt;h2&gt;
          You have {unreadMessages.length} unread messages.
        &lt;/h2&gt;
      }
    &lt;/div&gt;
  );
}

const messages = [&apos;React&apos;, &apos;Re: React&apos;, &apos;Re:Re: React&apos;];
ReactDOM.render(
  &lt;Mailbox unreadMessages={messages} /&gt;,
  document.getElementById(&apos;root&apos;)
);
在 CodePen 上尝试

之所以能这样做，是因为在 JavaScript 中，true &amp;&amp; expression 总是会返回 expression, 而 false &amp;&amp; expression 总是会返回 false。

因此，如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。

三目运算符
另一种内联条件渲染的方法是使用 JavaScript 中的三目运算符 condition ? true : false。

在下面这个示例中，我们用它来条件渲染一小段文本

render() {
  const isLoggedIn = this.state.isLoggedIn;
  return (
    &lt;div&gt;
      The user is &lt;b&gt;{isLoggedIn ? &apos;currently&apos; : &apos;not&apos;}&lt;/b&gt; logged in.
    &lt;/div&gt;
  );
}
同样的，它也可以用于较为复杂的表达式中，虽然看起来不是很直观：

render() {
  const isLoggedIn = this.state.isLoggedIn;
  return (
    &lt;div&gt;
      {isLoggedIn ? (
        &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;
      ) : (
        &lt;LoginButton onClick={this.handleLoginClick} /&gt;
      )}
    &lt;/div&gt;
  );
}
就像在 JavaScript 中一样，你可以根据团队的习惯来选择可读性更高的代码风格。需要注意的是，如果条件变得过于复杂，那你应该考虑如何提取组件。

阻止组件渲染
在极少数情况下，你可能希望能隐藏组件，即使它已经被其他组件渲染。若要完成此操作，你可以让 render 方法直接返回 null，而不进行任何渲染。

下面的示例中，&lt;WarningBanner /&gt; 会根据 prop 中 warn 的值来进行条件渲染。如果 warn 的值是 false，那么组件则不会渲染:

function WarningBanner(props) {
  if (!props.warn) {
    return null;
  }

  return (
    &lt;div className=&quot;warning&quot;&gt;
      Warning!
    &lt;/div&gt;
  );
}

class Page extends React.Component {
  constructor(props) {
    super(props);
    this.state = {showWarning: true};
    this.handleToggleClick = this.handleToggleClick.bind(this);
  }

  handleToggleClick() {
    this.setState(state =&gt; ({
      showWarning: !state.showWarning
    }));
  }

  render() {
    return (
      &lt;div&gt;
        &lt;WarningBanner warn={this.state.showWarning} /&gt;
        &lt;button onClick={this.handleToggleClick}&gt;
          {this.state.showWarning ? &apos;Hide&apos; : &apos;Show&apos;}
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;Page /&gt;,
  document.getElementById(&apos;root&apos;)
);
在 CodePen 上尝试

在组件的 render 方法中返回 null 并不会影响组件的生命周期。例如，上面这个示例中，componentDidUpdate 依然会被调用。
</code></pre><h2 id="列表-amp-Keys"><a href="#列表-amp-Keys" class="headerlink" title="列表 &amp; Keys"></a>列表 &amp; Keys</h2><pre><code>列表 &amp; Keys
首先，让我们看下在 Javascript 中如何转化列表。

如下代码，我们使用 map() 函数让数组中的每一项变双倍，然后我们得到了一个新的列表 doubled并打印出来：

const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((number) =&gt; number * 2);
console.log(doubled);
代码打印出 [2, 4, 6, 8, 10]。

在 React 中，把数组转化为元素 列表的过程是相似的。

渲染多个组件
你可以通过使用 {} 在 JSX 内构建一个元素集合。

下面，我们使用 Javascript 中的 map() 方法来遍历 numbers 数组。将数组中的每个元素变成 &lt;li&gt; 标签，最后我们将得到的数组赋值给 listItems：

const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) =&gt;
  &lt;li&gt;{number}&lt;/li&gt;
);
我们把整个 listItems 插入到 &lt;ul&gt; 元素中，然后渲染进 DOM：

ReactDOM.render(
  &lt;ul&gt;{listItems}&lt;/ul&gt;,
  document.getElementById(&apos;root&apos;)
);
在 CodePen 上尝试

这段代码生成了一个 1 到 5 的项目符号列表。

基础列表组件
通常你需要在一个组件 中渲染列表。

我们可以把前面的例子重构成一个组件，这个组件接收 numbers 数组作为参数并输出一个元素列表。

function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =&gt;
    &lt;li&gt;{number}&lt;/li&gt;
  );
  return (
    &lt;ul&gt;{listItems}&lt;/ul&gt;
  );
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  &lt;NumberList numbers={numbers} /&gt;,
  document.getElementById(&apos;root&apos;)
);
当我们运行这段代码，将会看到一个警告 a key should be provided for list items ，意思是当你创建一个元素时，必须包括一个特殊的 key 属性。我们将在下一节讨论这是为什么。

让我们来给每个列表元素分配一个 key 属性来解决上面的那个警告：

function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =&gt;
    &lt;li key={number.toString()}&gt;
      {number}
    &lt;/li&gt;
  );
  return (
    &lt;ul&gt;{listItems}&lt;/ul&gt;
  );
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  &lt;NumberList numbers={numbers} /&gt;,
  document.getElementById(&apos;root&apos;)
);
在 CodePen 上尝试

Keys
Keys 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。

const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) =&gt;
  &lt;li key={number.toString()}&gt;
    {number}
  &lt;/li&gt;
);
一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据 id 来作为元素的 key：

const todoItems = todos.map((todo) =&gt;
  &lt;li key={todo.id}&gt;
    {todo.text}
  &lt;/li&gt;
);
当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key：

const todoItems = todos.map((todo, index) =&gt;
  // Only do this if items have no stable IDs
  &lt;li key={index}&gt;
    {todo.text}
  &lt;/li&gt;
);
如果列表项目的顺序可能会变化，我们不建议使用索引来用作键值，因为这样做会导致性能变差，还可能引起组件状态的问题。可以看看 Robin Pokorny 的深度解析使用索引作为 key 的负面影响 这一篇文章。如果你选择不指定显式的键值，那么 React 将默认使用索引用作为列表项目的键值。

要是你有兴趣了解更多的话，这里有一篇文章深入解析为什么 keys 是必须的可以参考。

用 Keys 提取组件
元素的 Key 只有放在就近的数组上下文中才有意义。

比方说，如果你提取 出一个 ListItem 组件，你应该把 key 保留在数组中的这个 &lt;ListItem /&gt; 元素上，而不是放在 ListItem 组件中的 &lt;li&gt; 元素上。

** 例子：不正确的使用键的方式 **

function ListItem(props) {
  const value = props.value;
  return (
    // 错误！你不需要在这里指定 key:
    &lt;li key={value.toString()}&gt;
      {value}
    &lt;/li&gt;
  );
}

function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =&gt;
    // 错误！元素的 key 应该在这里指定：
    &lt;ListItem value={number} /&gt;
  );
  return (
    &lt;ul&gt;
      {listItems}
    &lt;/ul&gt;
  );
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  &lt;NumberList numbers={numbers} /&gt;,
  document.getElementById(&apos;root&apos;)
);
** 例子：正确的使用键的方式 **

function ListItem(props) {
  // 正确！这里不需要指定 key:
  return &lt;li&gt;{props.value}&lt;/li&gt;;
}

function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =&gt;
    // 正确！key 应该在数组的上下文中被指定
    &lt;ListItem key={number.toString()}
              value={number} /&gt;

  );
  return (
    &lt;ul&gt;
      {listItems}
    &lt;/ul&gt;
  );
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  &lt;NumberList numbers={numbers} /&gt;,
  document.getElementById(&apos;root&apos;)
);
在 CodePen 上尝试

一个好的经验法则是：在 map() 方法中的元素需要设置 keys 属性。

键（Key）只是在兄弟节点之间必须唯一
数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的键：

function Blog(props) {
  const sidebar = (
    &lt;ul&gt;
      {props.posts.map((post) =&gt;
        &lt;li key={post.id}&gt;
          {post.title}
        &lt;/li&gt;
      )}
    &lt;/ul&gt;
  );
  const content = props.posts.map((post) =&gt;
    &lt;div key={post.id}&gt;
      &lt;h3&gt;{post.title}&lt;/h3&gt;
      &lt;p&gt;{post.content}&lt;/p&gt;
    &lt;/div&gt;
  );
  return (
    &lt;div&gt;
      {sidebar}
      &lt;hr /&gt;
      {content}
    &lt;/div&gt;
  );
}

const posts = [
  {id: 1, title: &apos;Hello World&apos;, content: &apos;Welcome to learning React!&apos;},
  {id: 2, title: &apos;Installation&apos;, content: &apos;You can install React from npm.&apos;}
];
ReactDOM.render(
  &lt;Blog posts={posts} /&gt;,
  document.getElementById(&apos;root&apos;)
);
在 CodePen 上尝试

key 会传递信息给 React ，但不会传递给你的组件。如果你的组件中需要使用 key 属性的值，请用其他属性名显式传递这个值：

const content = posts.map((post) =&gt;
  &lt;Post
    key={post.id}
    id={post.id}
    title={post.title} /&gt;
);
上面例子中，Post 组件可以读出 props.id，但是不能读出 props.key。

在 JSX 中嵌入 map()
在上面的例子中，我们声明了一个单独的 listItems 变量并将其包含在 JSX 中：

function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =&gt;
    &lt;ListItem key={number.toString()}
              value={number} /&gt;

  );
  return (
    &lt;ul&gt;
      {listItems}
    &lt;/ul&gt;
  );
}
JSX 允许在大括号中嵌入任何表达式，所以我们可以内联 map() 返回的结果：

function NumberList(props) {
  const numbers = props.numbers;
  return (
    &lt;ul&gt;
      {numbers.map((number) =&gt;
        &lt;ListItem key={number.toString()}
                  value={number} /&gt;

      )}
    &lt;/ul&gt;
  );
}
在 CodePen 上尝试

这么做有时可以使你的代码更清晰，但有时这种风格也会被滥用。就像在 JavaScript 中一样，何时需要为了可读性提取出一个变量，这完全取决于你。但请记住，如果一个 map() 嵌套了太多层级，那可能就是你提取组件的一个好时机。
</code></pre><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><pre><code>在 React 里，HTML 表单元素的工作方式和其他的 DOM 元素有些不同，这是因为表单元素通常会保持一些内部的 state。例如这个纯 HTML 表单只接受一个名称：

&lt;form&gt;
  &lt;label&gt;
    名字:
    &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;
  &lt;/label&gt;
  &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
&lt;/form&gt;
此表单具有默认的 HTML 表单行为，即在用户提交表单后浏览到新页面。如果你在 React 中执行相同的代码，它依然有效。但大多数情况下，使用 JavaScript 函数可以很方便的处理表单的提交， 同时还可以访问用户填写的表单数据。实现这种效果的标准方式是使用“受控组件”。

受控组件
在 HTML 中，表单元素（如&lt;input&gt;、 &lt;textarea&gt; 和 &lt;select&gt;）之类的表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。

我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。

例如，如果我们想让前一个示例在提交时打印出名称，我们可以将表单写为受控组件：

class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: &apos;&apos;};

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert(&apos;提交的名字: &apos; + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      &lt;form onSubmit={this.handleSubmit}&gt;
        &lt;label&gt;
          名字:
          &lt;input type=&quot;text&quot; value={this.state.value} onChange={this.handleChange} /&gt;
        &lt;/label&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
      &lt;/form&gt;
    );
  }
}
在 CodePen 上尝试

由于在表单元素上设置了 value 属性，因此显示的值将始终为 this.state.value，这使得 React 的 state 成为唯一数据源。由于 handlechange 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。

对于受控组件来说，每个 state 突变都有一个相关的处理函数。这使得修改或验证用户输入变得简单。例如，如果我们要强制要求所有名称都用大写字母书写，我们可以将 handlechange 改写为：

handleChange(event) {
  this.setState({value: event.target.value.toUpperCase()});
}
textarea 标签
在 HTML 中, &lt;textarea&gt; 元素通过其子元素定义其文本:

&lt;textarea&gt;
  你好， 这是在 text area 里的文本
&lt;/textarea&gt;
而在 React 中，&lt;textarea&gt; 使用 value 属性代替。这样，可以使得使用 &lt;textarea&gt; 的表单和使用单行 input 的表单非常类似：

class EssayForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: &apos;请撰写一篇关于你喜欢的 DOM 元素的文章.&apos;
    };

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert(&apos;提交的文章: &apos; + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      &lt;form onSubmit={this.handleSubmit}&gt;
        &lt;label&gt;
          文章:
          &lt;textarea value={this.state.value} onChange={this.handleChange} /&gt;
        &lt;/label&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
      &lt;/form&gt;
    );
  }
}
请注意，this.state.value 初始化于构造函数中，因此文本区域默认有初值。

select 标签
在 HTML 中，&lt;select&gt; 创建下拉列表标签。例如，如下 HTML 创建了水果相关的下拉列表：

&lt;select&gt;
  &lt;option value=&quot;grapefruit&quot;&gt;葡萄柚&lt;/option&gt;
  &lt;option value=&quot;lime&quot;&gt;柠檬&lt;/option&gt;
  &lt;option selected value=&quot;coconut&quot;&gt;椰子&lt;/option&gt;
  &lt;option value=&quot;mango&quot;&gt;芒果&lt;/option&gt;
&lt;/select&gt;
请注意，由于 selected 属性的缘故，椰子选项默认被选中。React 并不会使用 selected 属性，而是在根 select 标签上使用 value 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。例如：

class FlavorForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: &apos;coconut&apos;};

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert(&apos;你喜欢的风味是: &apos; + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      &lt;form onSubmit={this.handleSubmit}&gt;
        &lt;label&gt;
          选择你喜欢的风味:
          &lt;select value={this.state.value} onChange={this.handleChange}&gt;
            &lt;option value=&quot;grapefruit&quot;&gt;葡萄柚&lt;/option&gt;
            &lt;option value=&quot;lime&quot;&gt;柠檬&lt;/option&gt;
            &lt;option value=&quot;coconut&quot;&gt;椰子&lt;/option&gt;
            &lt;option value=&quot;mango&quot;&gt;芒果&lt;/option&gt;
          &lt;/select&gt;
        &lt;/label&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
      &lt;/form&gt;
    );
  }
}
在 CodePen 上尝试

总的来说，这使得 &lt;input type=&quot;text&quot;&gt;, &lt;textarea&gt; 和 &lt;select&gt; 之类的标签都非常相似—它们都接受一个 value 属性，你可以使用它来实现受控组件。

注意

你可以将数组传递到 value 属性中，以支持在 select 标签中选择多个选项：

&lt;select multiple={true} value={[&apos;B&apos;, &apos;C&apos;]}&gt;
文件 input 标签
在 HTML 中，&lt;input type=“file”&gt; 允许用户从存储设备中选择一个或多个文件，将其上传到服务器，或通过使用 JavaScript 的 File API 进行控制。

&lt;input type=&quot;file&quot; /&gt;
因为它的 value 只读，所以它是 React 中的一个非受控组件。将与其他非受控组件在后续文档中一起讨论。

处理多个输入
当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作。

例如：

class Reservation extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      isGoing: true,
      numberOfGuests: 2
    };

    this.handleInputChange = this.handleInputChange.bind(this);
  }

  handleInputChange(event) {
    const target = event.target;
    const value = target.type === &apos;checkbox&apos; ? target.checked : target.value;
    const name = target.name;

    this.setState({
      [name]: value
    });
  }

  render() {
    return (
      &lt;form&gt;
        &lt;label&gt;
          参与:
          &lt;input
            name=&quot;isGoing&quot;
            type=&quot;checkbox&quot;
            checked={this.state.isGoing}
            onChange={this.handleInputChange} /&gt;
        &lt;/label&gt;
        &lt;br /&gt;
        &lt;label&gt;
          来宾人数:
          &lt;input
            name=&quot;numberOfGuests&quot;
            type=&quot;number&quot;
            value={this.state.numberOfGuests}
            onChange={this.handleInputChange} /&gt;
        &lt;/label&gt;
      &lt;/form&gt;
    );
  }
}
在 CodePen 上尝试

这里使用了 ES6 计算属性名称的语法更新给定输入名称对应的 state 值：

例如：

this.setState({
  [name]: value
});
等同 ES5:

var partialState = {};
partialState[name] = value;
this.setState(partialState);
另外，由于 setState() 自动将部分 state 合并到当前 state, 只需调用它更改部分 state 即可。

受控输入空值
在受控组件上指定 value 的 prop 可以防止用户更改输入。如果指定了 value，但输入仍可编辑，则可能是意外地将value 设置为 undefined 或 null。

下面的代码演示了这一点。（输入最初被锁定，但在短时间延迟后变为可编辑。）

ReactDOM.render(&lt;input value=&quot;hi&quot; /&gt;, mountNode);

setTimeout(function() {
  ReactDOM.render(&lt;input value={null} /&gt;, mountNode);
}, 1000);
受控组件的替代品
有时使用受控组件会很麻烦，因为你需要为数据变化的每种方式都编写事件处理函数，并通过一个 React 组件传递所有的输入 state。当你将之前的代码库转换为 React 或将 React 应用程序与非 React 库集成时，这可能会令人厌烦。在这些情况下，你可能希望使用非受控组件, 这是实现输入表单的另一种方式。
</code></pre><h2 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h2><pre><code>通常，多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去。让我们看看它是如何运作的。

在本节中，我们将创建一个用于计算水在给定温度下是否会沸腾的温度计算器。

我们将从一个名为 BoilingVerdict 的组件开始，它接受 celsius 温度作为一个 prop，并据此打印出该温度是否足以将水煮沸的结果。

function BoilingVerdict(props) {
  if (props.celsius &gt;= 100) {
    return &lt;p&gt;The water would boil.&lt;/p&gt;;
  }
  return &lt;p&gt;The water would not boil.&lt;/p&gt;;
}
接下来, 我们创建一个名为 Calculator 的组件。它渲染一个用于输入温度的 &lt;input&gt;，并将其值保存在 this.state.temperature 中。

另外, 它根据当前输入值渲染 BoilingVerdict 组件。

class Calculator extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {temperature: &apos;&apos;};
  }

  handleChange(e) {
    this.setState({temperature: e.target.value});
  }

  render() {
    const temperature = this.state.temperature;
    return (
      &lt;fieldset&gt;
        &lt;legend&gt;Enter temperature in Celsius:&lt;/legend&gt;
        &lt;input
          value={temperature}
          onChange={this.handleChange} /&gt;

        &lt;BoilingVerdict
          celsius={parseFloat(temperature)} /&gt;

      &lt;/fieldset&gt;
    );
  }
}
在 CodePen 上尝试

添加第二个输入框
我们的新需求是，在已有摄氏温度输入框的基础上，我们提供华氏度的输入框，并保持两个输入框的数据同步。

我们先从 Calculator 组件中抽离出 TemperatureInput 组件，然后为其添加一个新的 scale prop，它可以是 &quot;c&quot; 或是 &quot;f&quot;：

const scaleNames = {
  c: &apos;Celsius&apos;,
  f: &apos;Fahrenheit&apos;
};

class TemperatureInput extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {temperature: &apos;&apos;};
  }

  handleChange(e) {
    this.setState({temperature: e.target.value});
  }

  render() {
    const temperature = this.state.temperature;
    const scale = this.props.scale;
    return (
      &lt;fieldset&gt;
        &lt;legend&gt;Enter temperature in {scaleNames[scale]}:&lt;/legend&gt;
        &lt;input value={temperature}
               onChange={this.handleChange} /&gt;
      &lt;/fieldset&gt;
    );
  }
}
我们现在可以修改 Calculator 组件让它渲染两个独立的温度输入框组件：

class Calculator extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;TemperatureInput scale=&quot;c&quot; /&gt;
        &lt;TemperatureInput scale=&quot;f&quot; /&gt;
      &lt;/div&gt;
    );
  }
}
在 CodePen 上尝试

我们现在有了两个输入框，但当你在其中一个输入温度时，另一个并不会更新。这与我们的要求相矛盾：我们希望让它们保持同步。

另外，我们也不能通过 Calculator 组件展示 BoilingVerdict 组件的渲染结果。因为 Calculator 组件并不知道隐藏在 TemperatureInput 组件中的当前温度是多少。

编写转换函数
首先，我们将编写两个可以在摄氏度与华氏度之间相互转换的函数：

function toCelsius(fahrenheit) {
  return (fahrenheit - 32) * 5 / 9;
}

function toFahrenheit(celsius) {
  return (celsius * 9 / 5) + 32;
}
上述两个函数仅做数值转换。而我们将编写另一个函数，它接受字符串类型的 temperature 和转换函数作为参数并返回一个字符串。我们将使用它来依据一个输入框的值计算出另一个输入框的值。

当输入 temperature 的值无效时，函数返回空字符串，反之，则返回保留三位小数并四舍五入后的转换结果：

function tryConvert(temperature, convert) {
  const input = parseFloat(temperature);
  if (Number.isNaN(input)) {
    return &apos;&apos;;
  }
  const output = convert(input);
  const rounded = Math.round(output * 1000) / 1000;
  return rounded.toString();
}
例如，tryConvert(&apos;abc&apos;, toCelsius) 返回一个空字符串，而 tryConvert(&apos;10.22&apos;, toFahrenheit) 返回 &apos;50.396&apos;。

状态提升
到目前为止, 两个 TemperatureInput 组件均在各自内部的 state 中相互独立地保存着各自的数据。

class TemperatureInput extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {temperature: &apos;&apos;};
  }

  handleChange(e) {
    this.setState({temperature: e.target.value});
  }

  render() {
    const temperature = this.state.temperature;
    // ...  
然而，我们希望两个输入框内的数值彼此能够同步。当我们更新摄氏度输入框内的数值时，华氏度输入框内应当显示转换后的华氏温度，反之亦然。

在 React 中，将多个组件中需要共享的 state 向上移动到它们的最近共同父组件中，便可实现共享 state。这就是所谓的“状态提升”。接下来，我们将 TemperatureInput 组件中的 state 移动至 Calculator 组件中去。

如果 Calculator 组件拥有了共享的 state，它将成为两个温度输入框中当前温度的“数据源”。它能够使得两个温度输入框的数值彼此保持一致。由于两个 TemperatureInput 组件的 props 均来自共同的父组件 Calculator，因此两个输入框中的内容将始终保持一致。

让我们看看这是如何一步一步实现的。

首先，我们将 TemperatureInput 组件中的 this.state.temperature 替换为 this.props.temperature。现在，我们先假定 this.props.temperature 已经存在，尽管将来我们需要通过 Calculator 组件将其传入：

  render() {
    // Before: const temperature = this.state.temperature;
    const temperature = this.props.temperature;
    // ...
我们知道 props 是只读的。当 temperature 存在于 TemperatureInput 组件的 state 中时，组件调用 this.setState() 便可修改它。然而，temperature 是由父组件传入的 prop，TemperatureInput 组件便失去了对它的控制权。

在 React 中，这个问题通常是通过使用“受控组件”来解决的。与 DOM 中的 &lt;input&gt; 接受 value 和 onChange 一样，自定义的 TemperatureInput 组件接受 temperature 和 onTemperatureChange 这两个来自父组件 Calculator 的 props。

现在，当 TemperatureInput 组件想更新温度时，需调用 this.props.onTemperatureChange 来更新它：

  handleChange(e) {
    // Before: this.setState({temperature: e.target.value});
    this.props.onTemperatureChange(e.target.value);
    // ...
注意：

自定义组件中的 temperature 和 onTemperatureChange 这两个 prop 的命名没有任何特殊含义。我们可以给它们取其它任意的名字，例如，把它们命名为 value 和 onChange 就是一种习惯。

onTemperatureChange 的 prop 和 temperature 的 prop 一样，均由父组件 Calculator 提供。它通过修改父组件自身的内部 state 来处理数据的变化，进而使用新的数值重新渲染两个输入框。我们将很快看到修改后的 Calculator 组件效果。

在深入研究 Calculator 组件的变化之前，让我们回顾一下 TemperatureInput 组件的变化。我们移除组件自身的 state，通过使用 this.props.temperature 替代 this.state.temperature 来读取温度数据。当我们想要响应数据改变时，我们需要调用 Calculator 组件提供的 this.props.onTemperatureChange()，而不再使用 this.setState()。

class TemperatureInput extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
  }

  handleChange(e) {
    this.props.onTemperatureChange(e.target.value);
  }

  render() {
    const temperature = this.props.temperature;
    const scale = this.props.scale;
    return (
      &lt;fieldset&gt;
        &lt;legend&gt;Enter temperature in {scaleNames[scale]}:&lt;/legend&gt;
        &lt;input value={temperature}
               onChange={this.handleChange} /&gt;
      &lt;/fieldset&gt;
    );
  }
}
现在，让我们把目光转向 Calculator 组件。

我们会把当前输入的 temperature 和 scale 保存在组件内部的 state 中。这个 state 就是从两个输入框组件中“提升”而来的，并且它将用作两个输入框组件的共同“数据源”。这是我们为了渲染两个输入框所需要的所有数据的最小表示。

例如，当我们在摄氏度输入框中键入 37 时，Calculator 组件中的 state 将会是：

{
  temperature: &apos;37&apos;,
  scale: &apos;c&apos;
}
如果我们之后修改华氏度的输入框中的内容为 212 时，Calculator 组件中的 state 将会是：

{
  temperature: &apos;212&apos;,
  scale: &apos;f&apos;
}
我们可以存储两个输入框中的值，但这并不是必要的。我们只需要存储最近修改的温度及其计量单位即可，根据当前的 temperature 和 scale 就可以计算出另一个输入框的值。

由于两个输入框中的数值由同一个 state 计算而来，因此它们始终保持同步：

class Calculator extends React.Component {
  constructor(props) {
    super(props);
    this.handleCelsiusChange = this.handleCelsiusChange.bind(this);
    this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);
    this.state = {temperature: &apos;&apos;, scale: &apos;c&apos;};
  }

  handleCelsiusChange(temperature) {
    this.setState({scale: &apos;c&apos;, temperature});
  }

  handleFahrenheitChange(temperature) {
    this.setState({scale: &apos;f&apos;, temperature});
  }

  render() {
    const scale = this.state.scale;
    const temperature = this.state.temperature;
    const celsius = scale === &apos;f&apos; ? tryConvert(temperature, toCelsius) : temperature;
    const fahrenheit = scale === &apos;c&apos; ? tryConvert(temperature, toFahrenheit) : temperature;

    return (
      &lt;div&gt;
        &lt;TemperatureInput
          scale=&quot;c&quot;
          temperature={celsius}
          onTemperatureChange={this.handleCelsiusChange} /&gt;

        &lt;TemperatureInput
          scale=&quot;f&quot;
          temperature={fahrenheit}
          onTemperatureChange={this.handleFahrenheitChange} /&gt;

        &lt;BoilingVerdict
          celsius={parseFloat(celsius)} /&gt;

      &lt;/div&gt;
    );
  }
}
在 CodePen 上尝试

现在无论你编辑哪个输入框中的内容，Calculator 组件中的 this.state.temperature 和 this.state.scale 均会被更新。其中一个输入框保留用户的输入并取值，另一个输入框始终基于这个值显示转换后的结果。

让我们来重新梳理一下当你对输入框内容进行编辑时会发生些什么：

React 会调用 DOM 中 &lt;input&gt; 的 onChange 方法。在本实例中，它是 TemperatureInput 组件的 handleChange 方法。
TemperatureInput 组件中的 handleChange 方法会调用 this.props.onTemperatureChange()，并传入新输入的值作为参数。其 props 诸如 onTemperatureChange 之类，均由父组件 Calculator 提供。
起初渲染时，用于摄氏度输入的子组件 TemperatureInput 中 onTemperatureChange 方法为 Calculator 组件中的 handleCelsiusChange 方法，而，用于华氏度输入的子组件 TemperatureInput 中的 onTemperatureChange 方法为 Calculator 组件中的 handleFahrenheitChange 方法。因此，无论哪个输入框被编辑都会调用 Calculator 组件中对应的方法。
在这些方法内部，Calculator 组件通过使用新的输入值与当前输入框对应的温度计量单位来调用 this.setState() 进而请求 React 重新渲染自己本身。
React 调用 Calculator 组件的 render 方法得到组件的 UI 呈现。温度转换在这时进行，两个输入框中的数值通过当前输入温度和其计量单位来重新计算获得。
React 使用 Calculator 组件提供的新 props 分别调用两个 TemperatureInput 子组件的 render 方法来获取子组件的 UI 呈现。
React 调用 BoilingVerdict 组件的 render 方法，并将摄氏温度值以组件 props 方式传入。
React DOM 根据输入值匹配水是否沸腾，并将结果更新至 DOM。我们刚刚编辑的输入框接收其当前值，另一个输入框内容更新为转换后的温度值。
得益于每次的更新都经历相同的步骤，两个输入框的内容才能始终保持同步。
</code></pre><h2 id="组合-vs-继承"><a href="#组合-vs-继承" class="headerlink" title="组合 vs 继承"></a>组合 vs 继承</h2><pre><code>React 有十分强大的组合模式。我们推荐使用组合而非继承来实现组件间的代码重用。

在这篇文档中，我们将考虑初学 React 的开发人员使用继承时经常会遇到的一些问题，并展示如何通过组合思想来解决这些问题。

包含关系
有些组件无法提前知晓它们子组件的具体内容。在 Sidebar（侧边栏）和 Dialog（对话框）等展现通用容器（box）的组件中特别容易遇到这种情况。

我们建议这些组件使用一个特殊的 children prop 来将他们的子组件传递到渲染结果中：

function FancyBorder(props) {
  return (
    &lt;div className={&apos;FancyBorder FancyBorder-&apos; + props.color}&gt;
      {props.children}
    &lt;/div&gt;
  );
}
这使得别的组件可以通过 JSX 嵌套，将任意组件作为子组件传递给它们。

function WelcomeDialog() {
  return (
    &lt;FancyBorder color=&quot;blue&quot;&gt;
      &lt;h1 className=&quot;Dialog-title&quot;&gt;
        Welcome
      &lt;/h1&gt;
      &lt;p className=&quot;Dialog-message&quot;&gt;
        Thank you for visiting our spacecraft!
      &lt;/p&gt;
    &lt;/FancyBorder&gt;
  );
}
在 CodePen 上尝试

&lt;FancyBorder&gt; JSX 标签中的所有内容都会作为一个 children prop 传递给 FancyBorder 组件。因为 FancyBorder 将 {props.children} 渲染在一个 &lt;div&gt; 中，被传递的这些子组件最终都会出现在输出结果中。

少数情况下，你可能需要在一个组件中预留出几个“洞”。这种情况下，我们可以不使用 children，而是自行约定：将所需内容传入 props，并使用相应的 prop。

function SplitPane(props) {
  return (
    &lt;div className=&quot;SplitPane&quot;&gt;
      &lt;div className=&quot;SplitPane-left&quot;&gt;
        {props.left}
      &lt;/div&gt;
      &lt;div className=&quot;SplitPane-right&quot;&gt;
        {props.right}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

function App() {
  return (
    &lt;SplitPane
      left={
        &lt;Contacts /&gt;
      }
      right={
        &lt;Chat /&gt;
      } /&gt;
  );
}
在 CodePen 上尝试

&lt;Contacts /&gt; 和 &lt;Chat /&gt; 之类的 React 元素本质就是对象（object），所以你可以把它们当作 props，像其他数据一样传递。这种方法可能使你想起别的库中“槽”（slot）的概念，但在 React 中没有“槽”这一概念的限制，你可以将任何东西作为 props 进行传递。

特例关系
有些时候，我们会把一些组件看作是其他组件的特殊实例，比如 WelcomeDialog 可以说是 Dialog 的特殊实例。

在 React 中，我们也可以通过组合来实现这一点。“特殊”组件可以通过 props 定制并渲染“一般”组件：

function Dialog(props) {
  return (
    &lt;FancyBorder color=&quot;blue&quot;&gt;
      &lt;h1 className=&quot;Dialog-title&quot;&gt;
        {props.title}
      &lt;/h1&gt;
      &lt;p className=&quot;Dialog-message&quot;&gt;
        {props.message}
      &lt;/p&gt;
    &lt;/FancyBorder&gt;
  );
}

function WelcomeDialog() {
  return (
    &lt;Dialog
      title=&quot;Welcome&quot;
      message=&quot;Thank you for visiting our spacecraft!&quot; /&gt;

  );
}
在 CodePen 上尝试

组合也同样适用于以 class 形式定义的组件。

function Dialog(props) {
  return (
    &lt;FancyBorder color=&quot;blue&quot;&gt;
      &lt;h1 className=&quot;Dialog-title&quot;&gt;
        {props.title}
      &lt;/h1&gt;
      &lt;p className=&quot;Dialog-message&quot;&gt;
        {props.message}
      &lt;/p&gt;
      {props.children}
    &lt;/FancyBorder&gt;
  );
}

class SignUpDialog extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.handleSignUp = this.handleSignUp.bind(this);
    this.state = {login: &apos;&apos;};
  }

  render() {
    return (
      &lt;Dialog title=&quot;Mars Exploration Program&quot;
              message=&quot;How should we refer to you?&quot;&gt;
        &lt;input value={this.state.login}
               onChange={this.handleChange} /&gt;

        &lt;button onClick={this.handleSignUp}&gt;
          Sign Me Up!
        &lt;/button&gt;
      &lt;/Dialog&gt;
    );
  }

  handleChange(e) {
    this.setState({login: e.target.value});
  }

  handleSignUp() {
    alert(`Welcome aboard, ${this.state.login}!`);
  }
}
在 CodePen 上尝试

那么继承呢？
在 Facebook，我们在成百上千个组件中使用 React。我们并没有发现需要使用继承来构建组件层次的情况。

Props 和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式。注意：组件可以接受任意 props，包括基本数据类型，React 元素以及函数。

如果你想要在组件间复用非 UI 的功能，我们建议将其提取为一个单独的 JavaScript 模块，如函数、对象或者类。组件可以直接引入（import）而无需通过 extend 继承它们。
</code></pre><h2 id="React-哲学"><a href="#React-哲学" class="headerlink" title="React 哲学"></a>React 哲学</h2><pre><code>我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。

React 最棒的部分之一是引导我们思考如何构建一个应用。在这篇文档中，我们将会通过 React 构建一个可搜索的产品数据表格来更深刻地领会 React 哲学。

从设计稿开始
假设我们已经有了一个返回 JSON 的 API，以及设计师提供的组件设计稿。如下所示：

Mockup
该 JSON API 会返回以下数据：

[
  {category: &quot;Sporting Goods&quot;, price: &quot;$49.99&quot;, stocked: true, name: &quot;Football&quot;},
  {category: &quot;Sporting Goods&quot;, price: &quot;$9.99&quot;, stocked: true, name: &quot;Baseball&quot;},
  {category: &quot;Sporting Goods&quot;, price: &quot;$29.99&quot;, stocked: false, name: &quot;Basketball&quot;},
  {category: &quot;Electronics&quot;, price: &quot;$99.99&quot;, stocked: true, name: &quot;iPod Touch&quot;},
  {category: &quot;Electronics&quot;, price: &quot;$399.99&quot;, stocked: false, name: &quot;iPhone 5&quot;},
  {category: &quot;Electronics&quot;, price: &quot;$199.99&quot;, stocked: true, name: &quot;Nexus 7&quot;}
];
第一步：将设计好的 UI 划分为组件层级
首先，你需要在设计稿上用方框圈出每一个组件（包括它们的子组件），并且以合适的名称命名。如果你是和设计师一起完成此任务，那么他们可能已经做过类似的工作，所以请和他们进行交流！他们的 Photoshop 的图层名称可能最终就是你编写的 React 组件的名称！

但你如何确定应该将哪些部分划分到一个组件中呢？你可以将组件当作一种函数或者是对象来考虑，根据单一功能原则来判定组件的范围。也就是说，一个组件原则上只能负责一个功能。如果它需要负责更多的功能，这时候就应该考虑将它拆分成更小的组件。

在实践中，因为你经常是在向用户展示 JSON 数据模型，所以如果你的模型设计得恰当，UI（或者说组件结构）便会与数据模型一一对应，这是因为 UI 和数据模型都会倾向于遵守相同的信息结构。因此，将用户界面划分为组件的工作量就可以忽略不计了。只需使组件完全对应地展现数据模型的某部分即可。

Component diagram
你会看到我们的简单应用中包含五个组件。我们已经将每个组件展示的数据标注为了斜体。

FilterableProductTable (橙色): 是整个示例应用的整体
SearchBar (蓝色): 接受所有的用户输入
ProductTable (绿色): 展示数据内容并根据用户输入筛选结果
ProductCategoryRow (天蓝色): 为每一个产品类别展示标题
ProductRow (红色): 每一行展示一个产品
你可能注意到，ProductTable 的表头（包含 “Name” 和 “Price” 的那一部分）并未单独成为一个组件。这仅仅是一种偏好选择，如何处理这一问题也一直存在争论。就这个示例而言，因为表头只起到了渲染数据集合的作用——这与 ProductTable 是一致的，所以我们仍然将其保留为 ProductTable 的一部分。但是，如果表头过于复杂（比如我们需为其添加排序功能），那么将它作为一个独立的 ProductTableHeader 组件就显得很有必要了。

现在我们已经确定了设计稿中应该包含的组件，接下来我们将把它们描述为更加清晰的层级。设计稿中被其他组件包含的子组件，在层级上应该作为其子节点。

FilterableProductTable

SearchBar
ProductTable

ProductCategoryRow
ProductRow
第二步：用 React 创建一个静态版本
参阅 CodePen 上的 React 哲学：第二步。

现在我们已经确定了组件层级，可以编写对应的应用了。最容易的方式，是先用已有的数据模型渲染一个不包含交互功能的 UI。最好将渲染 UI 和添加交互这两个过程分开。这是因为，编写一个应用的静态版本时，往往要编写大量代码，而不需要考虑太多交互细节；添加交互功能时则要考虑大量细节，而不需要编写太多代码。所以，将这两个过程分开进行更为合适。我们会在接下来的代码中体会到其中的区别。

在构建应用的静态版本时，我们需要创建一些会重用其他组件的组件，然后通过 props 传入所需的数据。props 是父组件向子组件传递数据的方式。即使你已经熟悉了 state 的概念，也完全不应该使用 state 构建静态版本。state 代表了随时间会产生变化的数据，应当仅在实现交互时使用。所以构建应用的静态版本时，你不会用到它。

你可以自上而下或者自下而上构建应用：自上而下意味着首先编写层级较高的组件（比如 FilterableProductTable），自下而上意味着从最基本的组件开始编写（比如 ProductRow）。当你的应用比较简单时，使用自上而下的方式更方便；对于较为大型的项目来说，自下而上地构建，并同时为低层组件编写测试是更加简单的方式。

到此为止，你应该已经有了一个可重用的组件库来渲染你的数据模型。由于我们构建的是静态版本，所以这些组件目前只需提供 render() 方法用于渲染。最顶层的组件 FilterableProductTable 通过 props 接受你的数据模型。如果你的数据模型发生了改变，再次调用 ReactDOM.render()，UI 就会相应地被更新。数据模型变化、调用 render() 方法、UI 相应变化，这个过程并不复杂，因此很容易看清楚 UI 是如何被更新的，以及是在哪里被更新的。React 单向数据流（也叫单向绑定）的思想使得组件模块化，易于快速开发。

如果你在完成这一步骤时遇到了困难，可以参阅 React 文档。

补充说明: 有关 props 和 state
在 React 中，有两类“模型”数据：props 和 state。清楚地理解两者的区别是十分重要的；如果你不太有把握，可以参阅 React 官方文档。

第三步：确定 UI state 的最小（且完整）表示
想要使你的 UI 具备交互功能，需要有触发基础数据模型改变的能力。React 通过 state 来完成这个任务。

为了正确地构建应用，你首先需要找出应用所需的 state 的最小表示，并根据需要计算出其他所有数据。其中的关键正是 DRY: Don’t Repeat Yourself。只保留应用所需的可变 state 的最小集合，其他数据均由它们计算产生。比如，你要编写一个任务清单应用，你只需要保存一个包含所有事项的数组，而无需额外保存一个单独的 state 变量（用于存储任务个数）。当你需要展示任务个数时，只需要利用该数组的 length 属性即可。

我们的示例应用拥有如下数据：

包含所有产品的原始列表
用户输入的搜索词
复选框是否选中的值
经过搜索筛选的产品列表
通过问自己以下三个问题，你可以逐个检查相应数据是否属于 state：

该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。
该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。
你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。
包含所有产品的原始列表是经由 props 传入的，所以它不是 state；搜索词和复选框的值应该是 state，因为它们随时间会发生改变且无法由其他数据计算而来；经过搜索筛选的产品列表不是 state，因为它的结果可以由产品的原始列表根据搜索词和复选框的选择计算出来。

综上所述，属于 state 的有：

用户输入的搜索词
复选框是否选中的值
第四步：确定 state 放置的位置
参阅 CodePen 上的 React 哲学：第四步。

我们已经确定了应用所需的 state 的最小集合。接下来，我们需要确定哪个组件能够改变这些 state，或者说拥有这些 state。

注意：React 中的数据流是单向的，并顺着组件层级从上往下传递。哪个组件应该拥有某个 state 这件事，对初学者来说往往是最难理解的部分。尽管这可能在一开始不是那么清晰，但你可以尝试通过以下步骤来判断：

对于应用中的每一个 state：

找到根据这个 state 进行渲染的所有组件。
找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 state 的组件）。
该共同所有者组件或者比它层级更高的组件应该拥有该 state。
如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。
根据以上策略重新考虑我们的示例应用：

ProductTable 需要根据 state 筛选产品列表。SearchBar 需要展示搜索词和复选框的状态。
他们的共同所有者是 FilterableProductTable。
因此，搜索词和复选框的值应该很自然地存放在 FilterableProductTable 组件中。
很好，我们已经决定把这些 state 存放在 FilterableProductTable 组件中。首先，将实例属性 this.state = {filterText: &apos;&apos;, inStockOnly: false} 添加到 FilterableProductTable 的 constructor 中，设置应用的初始 state；接着，将 filterText 和 inStockOnly 作为 props 传入 ProductTable 和 SearchBar；最后，用这些 props 筛选 ProductTable 中的产品信息，并设置 SearchBar 的表单值。

你现在可以看到应用的变化了：将 filterText 设置为 &quot;ball&quot; 并刷新应用，你能发现表格中的数据已经更新了。

第五步：添加反向数据流
参阅 CodePen 上的 React 哲学：第五步。

到目前为止，我们已经借助自上而下传递的 props 和 state 渲染了一个应用。现在，我们将尝试让数据反向传递：处于较低层级的表单组件更新较高层级的 FilterableProductTable 中的 state。

React 通过一种比传统的双向绑定略微繁琐的方法来实现反向数据传递。尽管如此，但这种需要显式声明的方法更利于人们理解程序的运作方式。

如果你在这时尝试在搜索框输入或勾选复选框，React 不会产生任何响应。这是正常的，因为我们之前已经将 input 的值设置为了从 FilterableProductTable 的 state 传递而来的固定值。

让我们重新梳理一下需要实现的功能：每当用户改变表单的值，我们需要改变 state 来反映用户的当前输入。由于 state 只能由拥有它们的组件进行更改，FilterableProductTable 必须将一个能够触发 state 改变的回调函数（callback）传递给 SearchBar。我们可以使用输入框的 onChange 事件来监视用户输入的变化，并通知 FilterableProductTable 传递给 SearchBar 的回调函数。然后该回调函数将调用 setState()，从而更新应用。

尽管描述起来有点复杂，但实际上只是几行代码而已。你可以清楚地看到你的应用中数据是如何流动的。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/01/高济 JSBridge 开发文档/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/gaojihealth2.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高济无线团队">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/01/高济 JSBridge 开发文档/" itemprop="url">高济 JSBridge 开发文档</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-01T14:15:30+08:00">
                2019-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/文档/" itemprop="url" rel="index">
                    <span itemprop="name">文档</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/04/01/高济 JSBridge 开发文档/" class="leancloud_visitors" data-flag-title="高济 JSBridge 开发文档">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="复制文本到剪切板"><a href="#复制文本到剪切板" class="headerlink" title="复制文本到剪切板"></a>复制文本到剪切板</h5><p>name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pasteboardJSBridge</span><br></pre></td></tr></table></figure>
<p>params:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;pasteboardText&apos; : &apos;text content&apos;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="打开一个新-WebView-窗口"><a href="#打开一个新-WebView-窗口" class="headerlink" title="打开一个新 WebView 窗口"></a>打开一个新 WebView 窗口</h5><p>name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openNewWindowJSBridge</span><br></pre></td></tr></table></figure>
<p>params:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;url&apos; : &apos;https://xxxx&apos;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="调用-goback"><a href="#调用-goback" class="headerlink" title="调用 goback"></a>调用 goback</h5><p>name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gobackJSBridge</span><br></pre></td></tr></table></figure>
<p>params:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nil</span><br></pre></td></tr></table></figure>
<h5 id="Native-返回上一页"><a href="#Native-返回上一页" class="headerlink" title="Native 返回上一页"></a>Native 返回上一页</h5><p>name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">controllerPopJSBridge</span><br></pre></td></tr></table></figure>
<p>params:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nil</span><br></pre></td></tr></table></figure>
<h5 id="自定义标题"><a href="#自定义标题" class="headerlink" title="自定义标题"></a>自定义标题</h5><p>name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">controllerPopJSBridge</span><br></pre></td></tr></table></figure>
<p>params:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;titleString&apos;:&apos;title&apos;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h5><p>name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loginoutJSBridge</span><br></pre></td></tr></table></figure>
<p>params:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nil</span><br></pre></td></tr></table></figure>
<h5 id="设置导航栏右边按钮"><a href="#设置导航栏右边按钮" class="headerlink" title="设置导航栏右边按钮"></a>设置导航栏右边按钮</h5><p>name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navRightButtonTitle</span><br></pre></td></tr></table></figure>
<p>params:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;navRightButtonTitle&quot;:&quot;保存&quot;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="设置导航栏右边按钮隐藏"><a href="#设置导航栏右边按钮隐藏" class="headerlink" title="设置导航栏右边按钮隐藏"></a>设置导航栏右边按钮隐藏</h5><p>name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rightButtonHidenClick</span><br></pre></td></tr></table></figure>
<p>params:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nil</span><br></pre></td></tr></table></figure>
<h5 id="设置导航栏导航中间按钮"><a href="#设置导航栏导航中间按钮" class="headerlink" title="设置导航栏导航中间按钮"></a>设置导航栏导航中间按钮</h5><p>name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navCenterButtonJSBridge</span><br></pre></td></tr></table></figure>
<p>params:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;navCenterButtonTitle&quot;:&quot;花儿大药房&quot;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="设置导航栏导航中间按钮隐藏"><a href="#设置导航栏导航中间按钮隐藏" class="headerlink" title="设置导航栏导航中间按钮隐藏"></a>设置导航栏导航中间按钮隐藏</h5><p>name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navCenterButtonHidenJSBridge</span><br></pre></td></tr></table></figure>
<p>params:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nil</span><br></pre></td></tr></table></figure>
<h5 id="跳转-Native-业务模块"><a href="#跳转-Native-业务模块" class="headerlink" title="跳转 Native 业务模块"></a>跳转 Native 业务模块</h5><p>name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H5PushNativeRoute</span><br></pre></td></tr></table></figure>
<p>params:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//找native同事提供路由</span><br><span class="line">&#123;&quot;NativeRoute&quot;:&quot;gjhealth://cstore/member/memberQRCodeCard&quot;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="选择地址"><a href="#选择地址" class="headerlink" title="选择地址"></a>选择地址</h5><p>name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectAddressJSBridge</span><br></pre></td></tr></table></figure>
<p>params:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nil</span><br></pre></td></tr></table></figure>
<p>callback:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;logitudeString&quot; : 116.46</span><br><span class="line">    &quot;latitudeString&quot; : 39.92</span><br><span class="line">    &quot;addressString&quot; : 北京</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="选择组织"><a href="#选择组织" class="headerlink" title="选择组织"></a>选择组织</h5><p>name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectOrgBridge</span><br></pre></td></tr></table></figure>
<p>params:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;selectOrgType&quot;:&quot;2&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>callback:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;   &quot;orgId&quot; : xxx,</span><br><span class="line">    &quot;orgName&quot; : xxx,</span><br><span class="line">    &quot;orgType&quot; : xxx,</span><br><span class="line">    &quot;storeId&quot; : xxx,</span><br><span class="line">    &quot;userId&quot; : xxx,</span><br><span class="line">    &quot;storeName&quot; : xxx,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="扫一扫"><a href="#扫一扫" class="headerlink" title="扫一扫"></a>扫一扫</h5><p>name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QRCodeJSBridge</span><br></pre></td></tr></table></figure>
<p>params:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;title&quot;:&quot;请扫描二维码/条形码&quot;,</span><br><span class="line">    &quot;light&quot;:true,</span><br><span class="line">    &quot;codeType&quot;:0 //0 条形码 ,1 二维码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>callback:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; @&quot;QRCodeValueString&quot; : codeString&#125;</span><br></pre></td></tr></table></figure>
<h5 id="调用图表预览"><a href="#调用图表预览" class="headerlink" title="调用图表预览"></a>调用图表预览</h5><p>name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">previewImageJSBridge</span><br></pre></td></tr></table></figure>
<p>params:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;previewImageSelectIndex&quot;:&quot;0&quot;</span><br><span class="line"> &quot;previewImagesArray&quot;:[&quot;url1&quot;,&quot;url2&quot;,]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="保存图片到相册"><a href="#保存图片到相册" class="headerlink" title="保存图片到相册"></a>保存图片到相册</h5><p>name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">saveImageJSBridge</span><br></pre></td></tr></table></figure>
<p>params:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageBase64</span><br></pre></td></tr></table></figure>
<h5 id="分享图片"><a href="#分享图片" class="headerlink" title="分享图片"></a>分享图片</h5><p>name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shareImageJSBridge</span><br></pre></td></tr></table></figure>
<p>params:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageBase64</span><br></pre></td></tr></table></figure>
<h5 id="获取相册图片"><a href="#获取相册图片" class="headerlink" title="获取相册图片"></a>获取相册图片</h5><p>name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getImagesJSBridge</span><br></pre></td></tr></table></figure>
<p>params:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;imageCount&quot;:&quot;4&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>callback:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[imageBase64,imageBase64,imageBase64,imageBase64]</span><br></pre></td></tr></table></figure>
<h5 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h5><p>name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shareJSBridge</span><br></pre></td></tr></table></figure>
<p>params:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;title&quot;:&quot;iOS 分享组件&quot;,</span><br><span class="line">    &quot;description&quot;:&quot;高济医疗官网&quot;,</span><br><span class="line">    &quot;webpageUrl&quot;:&quot;http://www.gaojihealth.com&quot;,</span><br><span class="line">    &quot;thumbImageURL&quot;:&quot;https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3706507586,466188827&amp;fm=26&amp;gp=0.jpg&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用任务模块"><a href="#使用任务模块" class="headerlink" title="使用任务模块"></a>使用任务模块</h5><p>name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openTaskJSBridge</span><br></pre></td></tr></table></figure>
<p>params:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nil</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/01/JavaScript基础分享Ⅱ/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/gaojihealth2.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高济无线团队">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/01/JavaScript基础分享Ⅱ/" itemprop="url">进击的前端开发（JavaScript基础篇二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-01T13:28:39+08:00">
                2019-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/04/01/JavaScript基础分享Ⅱ/" class="leancloud_visitors" data-flag-title="进击的前端开发（JavaScript基础篇二）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="进击的前端开发（JavaScript基础篇二）"><a href="#进击的前端开发（JavaScript基础篇二）" class="headerlink" title="进击的前端开发（JavaScript基础篇二）"></a>进击的前端开发（JavaScript基础篇二）</h2><h3 id="Ⅲ-函数"><a href="#Ⅲ-函数" class="headerlink" title="Ⅲ. 函数"></a>Ⅲ. 函数</h3><h3 id="Ⅳ-标准对象"><a href="#Ⅳ-标准对象" class="headerlink" title="Ⅳ. 标准对象"></a>Ⅳ. 标准对象</h3><ul>
<li>Date</li>
<li>RegExp</li>
<li>JSON</li>
</ul>
<h3 id="Ⅴ-面向对象编程"><a href="#Ⅴ-面向对象编程" class="headerlink" title="Ⅴ. 面向对象编程"></a>Ⅴ. 面向对象编程</h3><ul>
<li>创建对象</li>
<li>原型继承</li>
<li>class继承</li>
</ul>
<h3 id="Ⅵ-浏览器"><a href="#Ⅵ-浏览器" class="headerlink" title="Ⅵ.浏览器"></a>Ⅵ.浏览器</h3><p>由于JavaScript的出现就是为了能在浏览器中运行，所以，浏览器自然是JavaScript开发者必须要关注的。</p>
<p>目前主流的浏览器分这么几种：</p>
<p>IE 6~11：国内用得最多的IE浏览器，历来对W3C标准支持差。从IE10开始支持ES6标准；</p>
<p>Chrome：Google出品的基于Webkit内核浏览器，内置了非常强悍的JavaScript引擎——V8。由于Chrome一经安装就时刻保持自升级，所以不用管它的版本，最新版早就支持ES6了；</p>
<p>Safari：Apple的Mac系统自带的基于Webkit内核的浏览器，从OS X 10.7 Lion自带的6.1版本开始支持ES6，目前最新的OS X 10.11 El Capitan自带的Safari版本是9.x，早已支持ES6；</p>
<p>Firefox：Mozilla自己研制的Gecko内核和JavaScript引擎OdinMonkey。早期的Firefox按版本发布，后来终于聪明地学习Chrome的做法进行自升级，时刻保持最新；</p>
<p>移动设备上目前iOS和Android两大阵营分别主要使用Apple的Safari和Google的Chrome，由于两者都是Webkit核心，结果HTML5首先在手机上全面普及（桌面绝对是Microsoft拖了后腿），对JavaScript的标准支持也很好，最新版本均支持ES6。</p>
<p>其他浏览器如Opera等由于市场份额太小就被自动忽略了。</p>
<p>另外还要注意识别各种国产浏览器，如某某安全浏览器，某某旋风浏览器，它们只是做了一个壳，其核心调用的是IE，也有号称同时支持IE和Webkit的“双核”浏览器。</p>
<p>不同的浏览器对JavaScript支持的差异主要是，有些API的接口不一样，比如AJAX，File接口。对于ES6标准，不同的浏览器对各个特性支持也不一样。</p>
<p>在编写JavaScript的时候，就要充分考虑到浏览器的差异，尽量让同一份JavaScript代码能运行在不同的浏览器中。</p>
<ul>
<li><p>浏览器对象</p>
<ul>
<li><p>window</p>
<p> window对象不但充当全局作用域，而且表示浏览器窗口。</p>
<p> window对象有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。</p>
<p> 对应的，还有一个outerWidth和outerHeight属性，可以获取浏览器窗口的整个宽高。</p>
</li>
<li><p>navigator</p>
<p> navigator对象表示浏览器的信息，最常用的属性包括：</p>
<p> navigator.appName：浏览器名称；<br> navigator.appVersion：浏览器版本；<br> navigator.language：浏览器设置的语言；<br> navigator.platform：操作系统类型；<br> navigator.userAgent：浏览器设定的User-Agent字符串。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;appName = &apos; + navigator.appName);</span><br><span class="line">console.log(&apos;appVersion = &apos; + navigator.appVersion);</span><br><span class="line">console.log(&apos;language = &apos; + navigator.language);</span><br><span class="line">console.log(&apos;platform = &apos; + navigator.platform);</span><br><span class="line">console.log(&apos;userAgent = &apos; + navigator.userAgent);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>screen</p>
<p> screen对象表示屏幕的信息，常用的属性有：</p>
<p> screen.width：屏幕宽度，以像素为单位；</p>
<p> screen.height：屏幕高度，以像素为单位；</p>
<p> screen.colorDepth：返回颜色位数，如8、16、24。</p>
</li>
<li><p>location</p>
<p> location对象表示当前页面的URL信息。例如，一个完整的URL：<br> <code>http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP</code><br> 可以用location.href获取。要获得URL各个部分的值，可以这么写：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location.protocol; // &apos;http&apos;</span><br><span class="line">location.host; // &apos;www.example.com&apos;</span><br><span class="line">location.port; // &apos;8080&apos;</span><br><span class="line">location.pathname; // &apos;/path/index.html&apos;</span><br><span class="line">location.search; // &apos;?a=1&amp;b=2&apos;</span><br><span class="line">location.hash; // &apos;TOP&apos;</span><br></pre></td></tr></table></figure>
<p> 要加载一个新页面，可以调用location.assign()。如果要重新加载当前页面，调用location.reload()方法非常方便。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      if (confirm(&apos;重新加载当前页&apos; + location.href + &apos;?&apos;)) &#123;</span><br><span class="line">    location.reload();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    location.assign(&apos;/&apos;); // 设置一个新的URL地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> document对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。</p>
<p> document的title属性是从HTML文档中的<title>xxx</title>读取的，但是可以动态改变：<br> <code>document.title = &#39;努力学习JavaScript!&#39;;//运行后观察浏览器窗口标题变化</code></p>
<p> 要查找DOM树的某个节点，需要从document对象开始查找。最常用的查找是根据ID和Tag Name。<br> 我们先准备HTML数据：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      &lt;dl id=&quot;drink-menu&quot; style=&quot;border:solid 1px #ccc;padding:6px;&quot;&gt;</span><br><span class="line">    &lt;dt&gt;摩卡&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;热摩卡咖啡&lt;/dd&gt;</span><br><span class="line">    &lt;dt&gt;酸奶&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;北京老酸奶&lt;/dd&gt;</span><br><span class="line">    &lt;dt&gt;果汁&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;鲜榨苹果汁&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure>
<p> 用document对象提供的getElementById()和getElementsByTagName()可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    var menu = document.getElementById(&apos;drink-menu&apos;);</span><br><span class="line">    var drinks = document.getElementsByTagName(&apos;dt&apos;);</span><br><span class="line">    var i, s, menu, drinks;</span><br><span class="line"></span><br><span class="line">menu = document.getElementById(&apos;drink-menu&apos;);</span><br><span class="line">menu.tagName; // &apos;DL&apos;</span><br><span class="line"></span><br><span class="line">drinks = document.getElementsByTagName(&apos;dt&apos;);</span><br><span class="line">s = &apos;提供的饮料有:&apos;;</span><br><span class="line">for (i=0; i&lt;drinks.length; i++) &#123;</span><br><span class="line">    s = s + drinks[i].innerHTML + &apos;,&apos;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(s);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>document</li>
<li>history<ul>
<li>操作DOM</li>
</ul>
</li>
<li>更新DOM</li>
<li>插入DOM</li>
<li>删除DOM<ul>
<li>操作表单</li>
<li>操作文件</li>
<li>AJAX</li>
<li>Promise</li>
<li>Canvas</li>
</ul>
</li>
</ul>
<h3 id="Ⅶ-jQuery"><a href="#Ⅶ-jQuery" class="headerlink" title="Ⅶ jQuery"></a>Ⅶ jQuery</h3><h3 id="Ⅷ-错误处理"><a href="#Ⅷ-错误处理" class="headerlink" title="Ⅷ 错误处理"></a>Ⅷ 错误处理</h3><h3 id="Ⅸ-underscore"><a href="#Ⅸ-underscore" class="headerlink" title="Ⅸ underscore"></a>Ⅸ underscore</h3><h3 id="Ⅹ-Node-js"><a href="#Ⅹ-Node-js" class="headerlink" title="Ⅹ Node.js"></a>Ⅹ Node.js</h3><h3 id="ⅩⅠ-React"><a href="#ⅩⅠ-React" class="headerlink" title="ⅩⅠ React"></a>ⅩⅠ React</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/01/html5 canvas分享/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/gaojihealth2.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高济无线团队">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/01/html5 canvas分享/" itemprop="url">进击的前端开发（HTML5 动画介绍）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-01T13:28:39+08:00">
                2019-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/04/01/html5 canvas分享/" class="leancloud_visitors" data-flag-title="进击的前端开发（HTML5 动画介绍）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HTML5-动画介绍"><a href="#HTML5-动画介绍" class="headerlink" title="HTML5 动画介绍"></a>HTML5 动画介绍</h2><h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h4><p>在 Web 开发中，经常需要实现各种动画效果，例如：移动、变形、透明度变化等，今天我们主要来讨论各种移动的实现。<br>在html5中常用的实现动画的方式主要有：Canvas，SVG Animation和CSS Transform,今天我们主要介绍的是Canvas</p>
<h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><h4 id="2-Canvas简介"><a href="#2-Canvas简介" class="headerlink" title="2.Canvas简介"></a>2.Canvas简介</h4><p>canvas是html5提供的一个新的功能！至于作用，就是一个画布。然后画笔就是javascript。canvas的用途非常的广，特别是html5游戏以及数据可视化这两个方面，可以不用太厉害，但是必须要会基础的用法。但是以后对canvas的需求，肯定会越来越大。所以canvas很值得学习，而且学好canvas,就是很好的一个加分项。不过,‘&lt;’canvas’&gt;’元素本身并没有绘制能力（它仅仅是图形的容器),必须使用脚本来完成实际的绘图任务。getContext() 方法可返回一个对象，该对象提供了用于在画布上绘图的方法和属性。</p>
<h4 id="3-常用函数"><a href="#3-常用函数" class="headerlink" title="3.常用函数"></a>3.常用函数</h4><h5 id="3-1基础函数"><a href="#3-1基础函数" class="headerlink" title="3.1基础函数"></a>3.1基础函数</h5><p>context.moveTo(x,y)<br>把画笔移动到x,y坐标，建立新的子路径。</p>
<p>context.lineTo(x,y)<br>建立上一个点到x,y坐标的直线，如果没有上一个点，则等同moveTo(x,y)，把（x,y）添加到子路径中。</p>
<p>context.stroke()<br>描绘子路径.</p>
<p>beginPath()<br>清空子路径，一般用于开始路径的创建。在几次循环地创建路径的过程中，每次开始创建时都要调用beginPath函数。</p>
<p>closePath()<br>如果当前子路径是打开的，就关闭它。否则把子路径中的最后一个点和路径中的第一个点连接起来，形成闭合回路。</p>
<h5 id="3-2绘制图像"><a href="#3-2绘制图像" class="headerlink" title="3.2绘制图像"></a>3.2绘制图像</h5><p>context.drawImage(image,x,y)<br>把image图像绘制到画布上x,y坐标位置。</p>
<p>context.drawImage(image,x,y,w,h)<br>把image图像绘制到画布上x,y坐标位置，图像的宽度是w,高度是h。</p>
<p>context.drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh)<br>截取image图像以sx,sy为左上角坐标，宽度为sw,高度为sh的一块矩形区域绘制到画布上以dx,dy坐标位置，图像宽度是dw,高度是dh。</p>
<h5 id="3-3艺术文字"><a href="#3-3艺术文字" class="headerlink" title="3.3艺术文字"></a>3.3艺术文字</h5><p>context.fillText(text,x,y,[maxWidth])<br>在canvas上填充文字，text表示需要绘制的文字，x,y分别表示绘制在canvas上的横，纵坐标，最后一个参数可选，表示显示文字的最大宽度，防止文字显示溢出。</p>
<p>context.strokeText(text,x,y,[maxWidth])<br>在canvas上描边文字，参数的意义同fillText</p>
<h4 id="4-Canvas的简单应用"><a href="#4-Canvas的简单应用" class="headerlink" title="4.Canvas的简单应用"></a>4.Canvas的简单应用</h4><p>利用canvas绘画出如图所以的环形html5时钟，<br><img src="../html/48B21005-4DCF-4452-B74E-06A5D971918D.png" alt="avatar"></p>
<p>主要函数：context.arc(x,y,r,sAngle,eAngle,counterclockwise);<br><img src="../html/56F4CD73-005D-4DAA-95A5-DABE4DE3026D.png" alt="avatar"></p>
<p>主要代码如下：</p>
<pre><code>function degToRad(degree){
    var factor = Math.PI/180;
    return degree*factor;
}
function renderTime(){
    var now = new Date();
    var today = now.toDateString();
    var time = now.toLocaleTimeString();
    var hrs = now.getHours();
    var min = now.getMinutes();
    var sec = now.getSeconds();
    var mil = now.getMilliseconds();
    var smoothsec = sec+(mil/1000);
      var smoothmin = min+(smoothsec/60);

    //Background
    gradient = ctx.createRadialGradient(250, 250, 5, 250, 250, 300);
    gradient.addColorStop(0, &quot;#03303a&quot;);
    gradient.addColorStop(1, &quot;black&quot;);
    ctx.fillStyle = gradient;
    //ctx.fillStyle = &apos;rgba(00 ,00 , 00, 1)&apos;;
    ctx.fillRect(0, 0, 500, 500);
    //Hours
    ctx.beginPath();
    ctx.arc(250,250,200, degToRad(270), degToRad((hrs*30)-90));
    ctx.stroke();
    //Minutes
    ctx.beginPath();
    ctx.arc(250,250,170, degToRad(270), degToRad((smoothmin*6)-90));
    ctx.stroke();
    //Seconds
    ctx.beginPath();
    ctx.arc(250,250,140, degToRad(270), degToRad((smoothsec*6)-90));
    ctx.stroke();
    //Date
    ctx.font = &quot;25px Helvetica&quot;;
    ctx.fillStyle = &apos;rgba(00, 255, 255, 1)&apos;
    ctx.fillText(today, 175, 250);
    //Time
    ctx.font = &quot;25px Helvetica Bold&quot;;
    ctx.fillStyle = &apos;rgba(00, 255, 255, 1)&apos;;
    ctx.fillText(time+&quot;:&quot;+mil, 175, 280);
}
</code></pre><h4 id="5-canvas动画实例"><a href="#5-canvas动画实例" class="headerlink" title="5.canvas动画实例"></a>5.canvas动画实例</h4><p>利用HTML5 Canvas技术实现的万花筒动画特效，动画开始时，逐渐生成一些随机颜色的矩形方块，然后就不停的旋转，就像万花筒一样，矩形方块越来越小。<br>如图：<br><img src="../html/ac3c8e80-d9c1-4dcc-9c55-ad373b06d5fb.png" alt="avatar"></p>
<p>主要代码：</p>
<pre><code>window.onload=function(){
        var canvas = document.getElementById(&quot;canvas&quot;);
        var context = canvas.getContext(&quot;2d&quot;);
        var rects= [];
        context.translate(200,200);
        setInterval(function(){
            context.clearRect(-200,-200,400,500);
            for(var i=0;i&lt;rects.length;i++){
                context.save();
                //    旋转当前绘图
                context.rotate(rects[i].angle * Math.PI / 180);
                //    缩放当前绘图
                context.scale(rects[i].scale,rects[i].scale);
                context.beginPath();
                context.fillStyle=rects[i].color;
                context.rect(rects[i].len,rects[i].len,50,50);
                context.fill();
                //    返回之前保存过的路径状态和属性
                context.restore();
            }
        },60);
        setInterval(function(){
            rects.push(createRect());
        },1000);
        setInterval(function(){
            for ( var i = 0; i &lt; rects.length; i++) {
                rects[i].len = rects[i].len -0.2;
                if(rects[i].len &lt;= 0){
                    rects.splice(i,1);
                    continue;
                }
                rects[i].scale = rects[i].scale - 0.002;
                if(rects[i].scale &lt;= 0.2){
                    rects[i].scale = 0.2;
                }
                rects[i].angle = rects[i].angle+2;
                if(rects[i].angle &gt;=360){
                    rects[i].angle =0;
                }

            }
        },60);
    };

function createRect(){
    var rect = {
            len:150,
            scale:1,
            angle:0,
            color:&quot;rgb(&quot;+getRandom()+&quot;,&quot;+getRandom()+&quot;,&quot;+getRandom()+&quot;)&quot;
    };
    return rect;
}
function getRandom(){
    return Math.floor(Math.random()*255);
}
</code></pre><blockquote>
<p>setTimeout() 实现的动画和 requestAnimationFrame() 实现的动画的区别</p>
</blockquote>
<h4 id="6-THREE-JS-和Canvas"><a href="#6-THREE-JS-和Canvas" class="headerlink" title="6. THREE.JS 和Canvas"></a>6. THREE.JS 和Canvas</h4><h5 id="6-1-three-js是做什么的"><a href="#6-1-three-js是做什么的" class="headerlink" title="6.1 three.js是做什么的"></a>6.1 three.js是做什么的</h5><p>webGL基于光栅化的2D API，封装成了我们人类能看懂的 3D API。</p>
<p>1.辅助我们导出了模型数据；</p>
<p>2.自动生成了各种矩阵；</p>
<p>3.生成了顶点着色器；</p>
<p>4.辅助我们生成材质，配置灯光；</p>
<p>5.根据我们设置的材质生成了片元着色器。</p>
<blockquote>
<p>开源地址：<a href="https://github.com/mrdoob/three.js" target="_blank" rel="noopener">https://github.com/mrdoob/three.js</a></p>
</blockquote>
<h5 id="6-2-three-js三大组件"><a href="#6-2-three-js三大组件" class="headerlink" title="6.2 three.js三大组件"></a>6.2 three.js三大组件</h5><h6 id="渲染器（Renderer）"><a href="#渲染器（Renderer）" class="headerlink" title="渲染器（Renderer）"></a>渲染器（Renderer）</h6><p>渲染器将和Canvas元素进行绑定</p>
<pre><code>var renderer = new THREE.WebGLRenderer({
    canvas: document.getElementById(‘mainCanvas’)
});
</code></pre><p>如果想要Three.js生成Canvas元素，在HTML中就不需要定义canvas，在js中可以这样写：</p>
<pre><code>var renderer = new THREE.WebGLRenderer();
renderer.setSize(400,300);
document.getElementsByTagName(‘body’[0].appendChild(renderer.domElement);
renderer.setClearColor(0x000000);
</code></pre><h6 id="场景（Scene）"><a href="#场景（Scene）" class="headerlink" title="场景（Scene）"></a>场景（Scene）</h6><p>　在Three.js中添加的物体都是添加到场景中的。在程序最开始的时候进行实例化，然后将物体添加到场景中即可。</p>
<pre><code>var scene = new THREE.Scene();
</code></pre><h6 id="照相机（Camera）"><a href="#照相机（Camera）" class="headerlink" title="照相机（Camera）"></a>照相机（Camera）</h6><p>webGL和Three.js使用的坐标系是右手坐标系：<br><img src="../html/899901-20160725133656700-2000808953.png" alt="avatar"><br>相机分正投影相机和透视投影相机。这里先定义一直透视投影的照相机</p>
<pre><code>var camera = new THREE.PerspectiveCamera(45,4/3,1,1000);
//四个参数分别对应：视角、近处的裁面的距离、远处的裁面的距离、实际窗口的纵横比（后面会详细讨论）
camera.position.set(0,0,5);//设置相机位置
scene.add(camera);//添加到场景中
</code></pre><h6 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h6><p>在定义了场景中的物体，设置好的照相机之后，渲染器就知道如何渲染出二维的结果了。调用渲染器的渲染函数，就能使其渲染一次了</p>
<pre><code>renderer.render(scene, camera);
</code></pre><h5 id="6-3-three-js案例"><a href="#6-3-three-js案例" class="headerlink" title="6.3 three.js案例"></a>6.3 three.js案例</h5><pre><code>&lt;!DOCTYPE html&gt;

&lt;html&gt;

&lt;head&gt;

&lt;meta charset=&quot;UTF-8&quot;&gt;

&lt;title&gt;3.js测试一&lt;/title&gt;

&lt;/head&gt;

&lt;body onload=&quot;init()&quot;&gt;

&lt;canvas id=&quot;mainCanvas&quot; width=&quot;400px&quot; height=&quot;300px&quot; &gt;&lt;/canvas&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;js/three.min.js&quot;&gt;&lt;/script&gt;&lt;!--路径改成你的--&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;

        function init() {

            // renderer 渲染器

            var renderer = new THREE.WebGLRenderer({

                canvas: document.getElementById(&apos;mainCanvas&apos;)　　//绑定canvas

            });

            renderer.setClearColor(0x000000); // black 



            // scene 场景

            var scene = new THREE.Scene();　　//实例化场景



            // camera 照相机

            var camera = new THREE.PerspectiveCamera(45, 4 / 3, 1, 1000);　　//透视投影相机参数设置

            camera.position.set(0, 0, 5);　　//相机位置设置

            scene.add(camera);　　//添加到场景



            // a cube in the scene 创建的物体

            var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 2, 3),　　//创建网格，参数一：几何体（立方体）

                    new THREE.MeshBasicMaterial({　　//参数二：材质（网格基础材质）

                        color: 0xff0000　　//设置颜色

                    })

            );

            scene.add(cube);　　//添加到场景



            // render 渲染

            renderer.render(scene, camera);

        }

    &lt;/script&gt;

&lt;/body&gt;

&lt;/html&gt;
</code></pre><blockquote>
<p>three.js初始化方法为init()</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/01/JavaScript基础分享Ⅰ/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/gaojihealth2.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高济无线团队">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/01/JavaScript基础分享Ⅰ/" itemprop="url">进击的前端开发（JavaScript基础篇一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-01T13:28:39+08:00">
                2019-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/04/01/JavaScript基础分享Ⅰ/" class="leancloud_visitors" data-flag-title="进击的前端开发（JavaScript基础篇一）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="进击的前端开发（JavaScript基础篇一）"><a href="#进击的前端开发（JavaScript基础篇一）" class="headerlink" title="进击的前端开发（JavaScript基础篇一）"></a>进击的前端开发（JavaScript基础篇一）</h2><h3 id="Ⅰ-JavaScript的历史"><a href="#Ⅰ-JavaScript的历史" class="headerlink" title="Ⅰ. JavaScript的历史"></a>Ⅰ. JavaScript的历史</h3><p>在上个世纪的1995年，当时的网景公司正凭借其Navigator浏览器成为Web时代开启时最著名的第一代互联网公司。<br>由于网景公司希望能在静态HTML页面上添加一些动态效果，于是叫Brendan Eich这哥们在两周之内设计出了JavaScript轻量级编程语言。<br>为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。</p>
<h3 id="Ⅱ-JavaScript快速入门"><a href="#Ⅱ-JavaScript快速入门" class="headerlink" title="Ⅱ. JavaScript快速入门"></a>Ⅱ. JavaScript快速入门</h3><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h4><p>JavaScript的语法和Java语言类似，每个语句以;结束，语句块用{…}。但是，JavaScript并不强制要求在每个语句的结尾加;，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上;。<br>例如，下面的一行代码就是一个完整的赋值语句：<br><code>var x = 1;</code></p>
<p>下面的一行代码是一个字符串，但仍然可以视为一个完整的语句：<br><code>&#39;Hello, world&#39;;</code></p>
<p>下面的一行代码包含两个语句，每个语句用;表示语句结束：<br><code>var x = 1; var y = 2; // 不建议一行写多个语句!</code></p>
<p>语句块是一组语句的集合，例如，下面的代码先做了一个判断，如果判断成立，将执行{…}中的所有语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (2 &gt; 1) &#123;</span><br><span class="line">    x = 1;    </span><br><span class="line">    y = 2;</span><br><span class="line">    z = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意花括号{…}内的语句具有缩进，通常是4个空格。缩进不是JavaScript语法要求必须的，但缩进有助于我们理解代码的层次，所以编写代码时要遵守缩进规则。很多文本编辑器具有“自动缩进”的功能，可以帮助整理代码。<br>{…}还可以嵌套，形成层级结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (2 &gt; 1) &#123;</span><br><span class="line">    x = 1;</span><br><span class="line">    y = 2;</span><br><span class="line">    z = 3;</span><br><span class="line">    if (x &lt; y) &#123;</span><br><span class="line">        z = 4;</span><br><span class="line">    &#125;</span><br><span class="line">    if (x &gt; y) &#123;</span><br><span class="line">        z = 5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript本身对嵌套的层级没有限制，但是过多的嵌套无疑会大大增加看懂代码的难度。遇到这种情况，需要把部分代码抽出来，作为函数来调用，这样可以减少代码的复杂度。</p>
<p>注释</p>
<p>以//开头直到行末的字符被视为行注释，注释是给开发人员看到，JavaScript引擎会自动忽略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这是一行注释</span><br><span class="line">alert(&apos;hello&apos;); // 这也是注释</span><br></pre></td></tr></table></figure>
<p>另一种块注释是用/<em>…</em>/把多行字符包裹起来，把一大“块”视为一个注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 从这里开始是块注释</span><br><span class="line">仍然是注释</span><br><span class="line">仍然是注释</span><br><span class="line">注释结束 */</span><br></pre></td></tr></table></figure>
<h4 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h4><p>在JavaScript中定义了以下几种数据类型：</p>
<h5 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h5><p>JavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">123; // 整数123</span><br><span class="line">0.456; // 浮点数0.456</span><br><span class="line">1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5</span><br><span class="line">-99; // 负数</span><br><span class="line">NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示</span><br><span class="line">Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span><br></pre></td></tr></table></figure>
<p>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等，它们和十进制表示的数值完全一样。<br>Number可以直接做四则运算，规则和数学一致：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 + 2; // 3</span><br><span class="line">(1 + 2) * 5 / 2; // 7.5</span><br><span class="line">2 / 0; // Infinity</span><br><span class="line">0 / 0; // NaN</span><br><span class="line">10 % 3; // 1</span><br><span class="line">10.5 % 3; // 1.5</span><br></pre></td></tr></table></figure>
<p>注意%是求余运算。</p>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。</p>
<ul>
<li>多行字符串</li>
</ul>
<p>由于多行字符串用\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 <code>...</code> 表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`这是一个</span><br><span class="line">多行</span><br><span class="line">字符串`;</span><br></pre></td></tr></table></figure>
<ul>
<li>模板字符串</li>
</ul>
<p>要把多个字符串连接起来，可以用+号连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;小明&apos;;</span><br><span class="line">var age = 20;</span><br><span class="line">var message = &apos;你好, &apos; + name + &apos;, 你今年&apos; + age + &apos;岁了!&apos;;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure>
<p>如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串，用<code></code>，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;小明&apos;;</span><br><span class="line">var age = 20;</span><br><span class="line">var message = `你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure>
<ul>
<li>操作字符串</li>
</ul>
<p>字符串常见的操作如下：</p>
<ul>
<li>获取字符串长度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;Hello, world!&apos;;</span><br><span class="line">s.length; // 13</span><br></pre></td></tr></table></figure>
<ul>
<li>要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;Hello, world!&apos;;</span><br><span class="line"></span><br><span class="line">s[0]; // &apos;H&apos;</span><br><span class="line">s[6]; // &apos; &apos;</span><br><span class="line">s[7]; // &apos;w&apos;</span><br><span class="line">s[12]; // &apos;!&apos;</span><br><span class="line">s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined</span><br><span class="line">需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：</span><br><span class="line">var s = &apos;Test&apos;;</span><br><span class="line">s[0] = &apos;X&apos;;</span><br><span class="line">alert(s); // s仍然为&apos;Test&apos;</span><br></pre></td></tr></table></figure>
<p>JavaScript为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串：</p>
<ul>
<li>toUpperCase()把一个字符串全部变为大写：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;Hello&apos;;</span><br><span class="line">s.toUpperCase(); // 返回&apos;HELLO&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>toLowerCase()把一个字符串全部变为小写：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;Hello&apos;;</span><br><span class="line">var lower = s.toLowerCase(); // 返回&apos;hello&apos;并赋值给变量lower</span><br><span class="line">lower; // &apos;hello&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>indexOf</p>
<p>indexOf()会搜索指定字符串出现的位置：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;hello, world&apos;;</span><br><span class="line">s.indexOf(&apos;world&apos;); // 返回7</span><br><span class="line">s.indexOf(&apos;World&apos;); // 没有找到指定的子串，返回-1</span><br></pre></td></tr></table></figure>
<ul>
<li><p>substring</p>
<p>substring()返回指定索引区间的子串：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;hello, world&apos;</span><br><span class="line">s.substring(0, 5); // 从索引0开始到5（不包括5），返回&apos;hello&apos;</span><br><span class="line">s.substring(7); // 从索引7开始到结束，返回&apos;world&apos;</span><br></pre></td></tr></table></figure>
<h5 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h5><p>布尔值和布尔代数的表示完全一致，一个布尔值只有true、false两种值，要么是true，要么是false，可以直接用true、false表示布尔值，也可以通过布尔运算计算出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true; // 这是一个true值</span><br><span class="line">false; // 这是一个false值</span><br><span class="line">2 &gt; 1; // 这是一个true值</span><br><span class="line">2 &gt;= 3; // 这是一个false值</span><br></pre></td></tr></table></figure>
<p>&amp;&amp;运算是与运算，只有所有都为true，&amp;&amp;运算结果才是true：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">true &amp;&amp; true; // 这个&amp;&amp;语句计算结果为true</span><br><span class="line">true &amp;&amp; false; // 这个&amp;&amp;语句计算结果为false</span><br><span class="line">false &amp;&amp; true &amp;&amp; false; // 这个&amp;&amp;语句计算结果为false</span><br></pre></td></tr></table></figure>
<p>||运算是或运算，只要其中有一个为true，||运算结果就是true：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">false || false; // 这个||语句计算结果为false</span><br><span class="line">true || false; // 这个||语句计算结果为true</span><br><span class="line">false || true || false; // 这个||语句计算结果为true</span><br></pre></td></tr></table></figure>
<p>!运算是非运算，它是一个单目运算符，把true变成false，false变成true：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">! true; // 结果为false</span><br><span class="line">! false; // 结果为true</span><br><span class="line">! (2 &gt; 5); // 结果为true</span><br></pre></td></tr></table></figure>
<p>布尔值经常用在条件判断中，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var age = 15;</span><br><span class="line">if (age &gt;= 18) &#123;</span><br><span class="line">    alert(&apos;adult&apos;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&apos;teenager&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><p>当我们对Number做比较时，可以通过比较运算符得到一个布尔值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 &gt; 5; // false</span><br><span class="line">5 &gt;= 2; // true</span><br><span class="line">7 == 7; // true</span><br></pre></td></tr></table></figure>
<p>实际上，JavaScript允许对任意数据类型做比较：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false == 0; // true</span><br><span class="line">false === 0; // false</span><br></pre></td></tr></table></figure>
<p>要特别注意相等运算符==。JavaScript在设计时，有两种比较运算符：<br>第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；</p>
<p>第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。</p>
<p>由于JavaScript这个设计缺陷，不要使用==比较，<strong>始终坚持使用===比较</strong>。</p>
<p>另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己：<br><code>NaN === NaN; // false</code></p>
<p>唯一能判断NaN的方法是通过isNaN()函数：<br><code>isNaN(NaN); // true</code></p>
<p>最后要注意浮点数的相等比较：<br><code>1 / 3 === (1 - 2 / 3); // false</code></p>
<p>这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：<br><code>Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true</code></p>
<h5 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h5><p>null表示一个“空”的值，它和0以及空字符串’’不同，0是一个数值，’’表示长度为0的字符串，而null表示“空”。</p>
<p>在其他语言中，也有类似JavaScript的null的表示，例如Java也用null，Swift用nil，Python用None表示。但是，在JavaScript中，还有一个和null类似的undefined，它表示“未定义”。</p>
<p>JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。</p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。<br>例如：</p>
<p><code>[1, 2, 3.14, &#39;Hello&#39;, null, true];</code></p>
<p>上述数组包含6个元素。数组用[]表示，元素之间用,分隔。</p>
<p>另一种创建数组的方法是通过Array()函数实现：</p>
<p><code>new Array(1, 2, 3); // 创建了数组[1, 2, 3]</code></p>
<p>然而，出于代码的可读性考虑，强烈建议直接使用[]。</p>
<ul>
<li>数组的元素可以通过索引来访问。请注意，索引的起始值为0：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3.14, &apos;Hello&apos;, null, true];</span><br><span class="line">arr[0]; // 返回索引为0的元素，即1</span><br><span class="line">arr[5]; // 返回索引为5的元素，即true</span><br><span class="line">arr[6]; // 索引超出了范围，返回undefined</span><br></pre></td></tr></table></figure>
<ul>
<li>要取得Array的长度，直接访问length属性：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3.14, &apos;Hello&apos;, null, true];</span><br><span class="line">arr.length; // 6</span><br></pre></td></tr></table></figure>
<p>请注意，直接给Array的length赋一个新的值会导致Array大小的变化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr.length; // 3</span><br><span class="line">arr.length = 6;</span><br><span class="line">arr; // arr变为[1, 2, 3, undefined, undefined, undefined]</span><br><span class="line">arr.length = 2;</span><br><span class="line">arr; // arr变为[1, 2]</span><br></pre></td></tr></table></figure>
<p>Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</span><br><span class="line">arr[1] = 99;</span><br><span class="line">arr; // arr现在变为[&apos;A&apos;, 99, &apos;C&apos;]</span><br></pre></td></tr></table></figure>
<p>请注意，如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr[5] = &apos;x&apos;;</span><br><span class="line">arr; // arr变为[1, 2, 3, undefined, undefined, &apos;x&apos;]</span><br></pre></td></tr></table></figure>
<p>大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，<strong>访问索引时要确保索引不会越界</strong>。</p>
<ul>
<li><p>indexOf</p>
<p>与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [10, 20, &apos;30&apos;, &apos;xyz&apos;];</span><br><span class="line">arr.indexOf(10); // 元素10的索引为0</span><br><span class="line">arr.indexOf(20); // 元素20的索引为1</span><br><span class="line">arr.indexOf(30); // 元素30没有找到，返回-1</span><br><span class="line">arr.indexOf(&apos;30&apos;); // 元素&apos;30&apos;的索引为2</span><br></pre></td></tr></table></figure>
<p>注意了，数字30和字符串’30’是不同的元素。</p>
<ul>
<li><p>slice</p>
<p>slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;];</span><br><span class="line">arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</span><br><span class="line">arr.slice(3); // 从索引3开始到结束: [&apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;]</span><br></pre></td></tr></table></figure>
<p>注意到slice()的起止参数包括开始索引，不包括结束索引。</p>
<p>如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;];</span><br><span class="line">var aCopy = arr.slice();</span><br><span class="line">aCopy; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;]</span><br><span class="line">aCopy === arr; // false</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>push和pop</p>
<p>push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2];</span><br><span class="line">arr.push(&apos;A&apos;, &apos;B&apos;); // 返回Array新的长度: 4</span><br><span class="line">arr; // [1, 2, &apos;A&apos;, &apos;B&apos;]</span><br><span class="line">arr.pop(); // pop()返回&apos;B&apos;</span><br><span class="line">arr; // [1, 2, &apos;A&apos;]</span><br><span class="line">arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次</span><br><span class="line">arr; // []</span><br><span class="line">arr.pop(); // 空数组继续pop不会报错，而是返回undefined</span><br><span class="line">arr; // []</span><br></pre></td></tr></table></figure>
<ul>
<li><p>unshift和shift</p>
<p>如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2];</span><br><span class="line">arr.unshift(&apos;A&apos;, &apos;B&apos;); // 返回Array新的长度: 4</span><br><span class="line">arr; // [&apos;A&apos;, &apos;B&apos;, 1, 2]</span><br><span class="line">arr.shift(); // &apos;A&apos;</span><br><span class="line">arr; // [&apos;B&apos;, 1, 2]</span><br><span class="line">arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次</span><br><span class="line">arr; // []</span><br><span class="line">arr.shift(); // 空数组继续shift不会报错，而是返回undefined</span><br><span class="line">arr; // []</span><br></pre></td></tr></table></figure>
<ul>
<li><p>sort</p>
<p>sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;B&apos;, &apos;C&apos;, &apos;A&apos;];</span><br><span class="line">arr.sort();</span><br><span class="line">arr; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>reverse</p>
<p>reverse()把整个Array的元素进行反转：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;];</span><br><span class="line">arr.reverse(); </span><br><span class="line">arr; // [&apos;three&apos;, &apos;two&apos;, &apos;one&apos;]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>splice</p>
<p>splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;];</span><br><span class="line">// 从索引2开始删除3个元素,然后再添加两个元素:</span><br><span class="line">arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;]</span><br><span class="line">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]</span><br><span class="line">// 只删除,不添加:</span><br><span class="line">arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;]</span><br><span class="line">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;]</span><br><span class="line">// 只添加,不删除:</span><br><span class="line">arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;); // 返回[],因为没有删除任何元素</span><br><span class="line">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>concat</p>
<p>concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</span><br><span class="line">var added = arr.concat([1, 2, 3]);</span><br><span class="line">added; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 1, 2, 3]</span><br><span class="line">arr; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</span><br></pre></td></tr></table></figure>
<p>请注意，concat()方法并没有修改当前Array，而是返回了一个新的Array。<br>实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</span><br><span class="line">arr.concat(1, 2, [3, 4]); // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>join</p>
<p>join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 1, 2, 3];</span><br><span class="line">arr.join(&apos;-&apos;); // &apos;A-B-C-1-2-3&apos;</span><br></pre></td></tr></table></figure>
<p>如果Array的元素不是字符串，将自动转换为字符串后再连接。</p>
<h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5><p>如果数组的某个元素又是一个Array，则可以形成多维数组，例如：<br><code>var arr = [[1, 2, 3], [400, 500, 600], &#39;-&#39;];</code><br>上述Array包含3个元素，其中头两个元素本身也是Array。</p>
<h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5><p>JavaScript的对象是一组由键-值组成的无序集合，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: ‘kk&apos;,</span><br><span class="line">    age: 20,</span><br><span class="line">    tags: [&apos;js&apos;, &apos;web&apos;,’android’,’ios&apos;],</span><br><span class="line">    city: &apos;Beijing&apos;,</span><br><span class="line">    hasCar: false,</span><br><span class="line">    zipcode: null</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>JavaScript对象的键都是字符串类型，值可以是任意数据类型。</p>
<p>上述person对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，person的name属性为’kk’，zipcode属性为null。</p>
<p>要获取一个对象的属性，我们用对象变量.属性名的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person.name; // ‘kk&apos;</span><br><span class="line">person.zipcode; // null</span><br></pre></td></tr></table></figure>
<p>访问属性是通过.操作符完成的，但这要求<strong>属性名必须是一个有效的变量名</strong>。如果属性名包含特殊字符，就必须用’’括起来,比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var student = &#123;</span><br><span class="line">    name: &apos;kk&apos;,</span><br><span class="line">    &apos;middle-school&apos;: ‘一中&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>student的属性名middle-school不是一个有效的变量，<strong>变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字</strong>,就需要用’’括起来。访问这个属性也无法使用.操作符，必须用[‘xxx’]来访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">student[&apos;middle-school&apos;];</span><br><span class="line">student[&apos;name&apos;]; </span><br><span class="line">student;</span><br></pre></td></tr></table></figure>
<p>如果访问一个不存在的属性，JavaScript规定，访问不存在的属性不报错，而是返回undefined。</p>
<p>由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var student = &#123;</span><br><span class="line">    name: &apos;小明&apos;</span><br><span class="line">&#125;;</span><br><span class="line">student; // undefined</span><br><span class="line">student.age = 18; // 新增一个age属性</span><br><span class="line">student.age; // 18</span><br><span class="line">delete student.age; // 删除age属性</span><br><span class="line">student.age; // undefined</span><br><span class="line">delete student[&apos;name&apos;]; // 删除name属性</span><br><span class="line">student.name; // undefined</span><br><span class="line">delete student.school; // 删除一个不存在的school属性也不会报错</span><br></pre></td></tr></table></figure>
<p>如果我们要检测student是否拥有某一属性，可以用in操作符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var student = &#123;</span><br><span class="line">    name: &apos;小明&apos;,</span><br><span class="line">    birth: 1990,</span><br><span class="line">    school: &apos;No.1 Middle School&apos;,</span><br><span class="line">    height: 1.70,</span><br><span class="line">    weight: 65,</span><br><span class="line">    score: null</span><br><span class="line">&#125;;</span><br><span class="line">&apos;name&apos; in student; // true</span><br><span class="line">&apos;grade&apos; in student; // false</span><br></pre></td></tr></table></figure>
<p>不过要小心，如果in判断一个属性存在，这个属性不一定是student的，它可能是student继承得到的：<br><code>&#39;toString&#39; in student; // true</code><br>因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以student也拥有toString属性。<br>要判断一个属性是否是student自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var student = &#123;</span><br><span class="line">    name: &apos;小明&apos;</span><br><span class="line">&#125;;</span><br><span class="line">student.hasOwnProperty(&apos;name&apos;); // true</span><br><span class="line">student.hasOwnProperty(&apos;toString&apos;); // false</span><br></pre></td></tr></table></figure>
<p>3.变量</p>
<p>变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p>
<p>变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。申明一个变量用var语句，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a; // 申明了变量a，此时a的值为undefined</span><br><span class="line">var $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1</span><br><span class="line">var s_007 = &apos;007&apos;; // s_007是一个字符串</span><br><span class="line">var Answer = true; // Answer是一个布尔值true</span><br><span class="line">var t = null; // t的值是null</span><br></pre></td></tr></table></figure>
<p>变量名也可以用中文，但是为了编码规范，尽量不要用中文。</p>
<p>在JavaScript中，使用等号=对变量进行赋值。可以把任意数据类型赋值给变量，<strong>同一个变量可以反复赋值</strong>，而且可以是不同类型的变量，但是要注意<strong>只能用var申明一次</strong>，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 123; // a的值是整数123</span><br><span class="line">a = &apos;ABC&apos;; // a变为字符串</span><br></pre></td></tr></table></figure>
<p>这种<strong>变量本身类型不固定的语言称之为动态语言</strong>，与之对应的是静态语言。<strong>静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错</strong>。例如Java是静态语言，赋值语句如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 123; // a是整数类型变量，类型用int申明</span><br><span class="line">a = &quot;ABC&quot;; // 错误：不能把字符串赋给整型变量</span><br></pre></td></tr></table></figure>
<p>和静态语言相比，动态语言更灵活，就是这个原因。<br>请不要把赋值语句的等号等同于数学的等号。比如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x = 10;</span><br><span class="line">x = x + 2;</span><br></pre></td></tr></table></figure>
<p>strict模式</p>
<p>JavaScript在设计之初，为了方便初学者学习，并不强制要求用var申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量：</p>
<p><code>i = 10; // i现在是全局变量</code><br>在同一个页面的不同的JavaScript文件中，如果都不用var申明，恰好都使用了变量i，将造成变量i互相影响，产生难以调试的错误结果。</p>
<p><strong>使用var申明的变量则不是全局变量</strong>，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。</p>
<p>为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误。</p>
<p>启用strict模式的方法是在JavaScript代码的第一行写上：</p>
<p><code>&#39;use strict&#39;;</code></p>
<p>这是一个字符串，不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。</p>
<h4 id="4-条件判断"><a href="#4-条件判断" class="headerlink" title="4.条件判断"></a>4.条件判断</h4><p>JavaScript使用<code>if () { ... } else { ... }</code>来进行条件判断。例如，根据年龄显示不同内容，可以用if语句实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var age = 20;</span><br><span class="line">if (age &gt;= 18) &#123; // 如果age &gt;= 18为true，则执行if语句块</span><br><span class="line">    alert(&apos;adult&apos;);</span><br><span class="line">&#125; else &#123; // 否则执行else语句块</span><br><span class="line">    alert(&apos;teenager&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中else语句是可选的。如果语句块只包含一条语句，那么可以省略{}：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var age = 20;</span><br><span class="line">if (age &gt;= 18)</span><br><span class="line">    alert(&apos;adult&apos;);</span><br><span class="line">else</span><br><span class="line">    alert(&apos;teenager&apos;);</span><br></pre></td></tr></table></figure>
<p>省略{}的危险之处在于，如果后来想添加一些语句，却忘了写{}，就改变了if…else…的语义，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var age = 20;</span><br><span class="line">if (age &gt;= 18)</span><br><span class="line">    alert(&apos;adult&apos;);</span><br><span class="line">else</span><br><span class="line">    console.log(&apos;age &lt; 18&apos;); // 添加一行日志</span><br><span class="line">    alert(&apos;teenager&apos;); // &lt;- 这行语句已经不在else的控制范围了</span><br></pre></td></tr></table></figure>
<p>上述代码的else子句实际上只负责执行<code>console.log(&#39;age &lt; 18&#39;);</code>，原有的<code>alert(&#39;teenager&#39;);</code>已经不属于if…else…的控制范围了，它每次都会执行。</p>
<p>相反地，有{}的语句就不会出错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var age = 20;</span><br><span class="line">if (age &gt;= 18) &#123;</span><br><span class="line">    alert(&apos;adult&apos;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&apos;age &lt; 18&apos;);</span><br><span class="line">    alert(&apos;teenager&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是为什么我们建议<strong>永远都要写上{}</strong>。</p>
<p>多行条件判断<br>如果还要更细致地判断条件，可以使用多个<code>if...else...</code>的组合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var age = 3;</span><br><span class="line">if (age &gt;= 18) &#123;</span><br><span class="line">    alert(&apos;adult&apos;);</span><br><span class="line">&#125; else if (age &gt;= 6) &#123;</span><br><span class="line">    alert(&apos;teenager&apos;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&apos;kid&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述多个if…else…的组合实际上相当于两层if…else…：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var age = 3;</span><br><span class="line">if (age &gt;= 18) &#123;</span><br><span class="line">    alert(&apos;adult&apos;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    if (age &gt;= 6) &#123;</span><br><span class="line">        alert(&apos;teenager&apos;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        alert(&apos;kid&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们通常把else if连写在一起，来增加可读性。这里的else略掉了{}是没有问题的，因为它只包含一个if语句。注意最后一个单独的else不要略掉{}。</p>
<p>请注意，if…else…语句的执行特点是二选一，在多个if…else…语句中，如果某个条件成立，则后续就不再继续判断了。</p>
<h4 id="5-循环"><a href="#5-循环" class="headerlink" title="5.循环"></a>5.循环</h4><ul>
<li>JavaScript的循环有两种，一种是for循环，通过初始条件、结束条件和递增条件来循环执行语句块：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x = 0;</span><br><span class="line">var i;</span><br><span class="line">for (i=1; i&lt;=10000; i++) &#123;</span><br><span class="line">    x = x + i;</span><br><span class="line">&#125;</span><br><span class="line">x; // 50005000</span><br></pre></td></tr></table></figure>
<p>for循环最常用的地方是利用索引来遍历数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;Apple&apos;, &apos;Google&apos;, &apos;Microsoft&apos;];</span><br><span class="line">var i, x;</span><br><span class="line">for (i=0; i&lt;arr.length; i++) &#123;</span><br><span class="line">    x = arr[i];</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用break语句退出循环，否则就是死循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = 0;</span><br><span class="line">for (;;) &#123; // 将无限循环下去</span><br><span class="line">    if (x &gt; 100) &#123;</span><br><span class="line">        break; // 通过if判断来退出循环</span><br><span class="line">    &#125;</span><br><span class="line">    x ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>for … in</p>
<p>for循环的一个变体是for … in循环，它可以把一个对象的所有属性依次循环出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    name: &apos;Jack&apos;,</span><br><span class="line">    age: 20,</span><br><span class="line">    city: &apos;Beijing&apos;</span><br><span class="line">&#125;;</span><br><span class="line">for (var key in o) &#123;</span><br><span class="line">    console.log(key); // &apos;name&apos;, &apos;age&apos;, &apos;city&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要过滤掉对象继承的属性，用hasOwnProperty()来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    name: &apos;Jack&apos;,</span><br><span class="line">    age: 20,</span><br><span class="line">    city: &apos;Beijing&apos;</span><br><span class="line">&#125;;</span><br><span class="line">for (var key in o) &#123;</span><br><span class="line">    if (o.hasOwnProperty(key)) &#123;</span><br><span class="line">        console.log(key); // &apos;name&apos;, &apos;age&apos;, &apos;city&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for … in循环可以直接循环出Array的索引：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</span><br><span class="line">for (var i in a) &#123;</span><br><span class="line">    console.log(i); // &apos;0&apos;, &apos;1&apos;, &apos;2&apos;</span><br><span class="line">    console.log(a[i]); // &apos;A&apos;, &apos;B&apos;, &apos;C&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，for … in对Array的循环得到的是String而不是Number。</p>
<ul>
<li><p>while</p>
<p> for循环在已知循环的初始和结束条件时非常有用。</p>
<p> while循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = 0;</span><br><span class="line">var n = 99;</span><br><span class="line">while (n &gt; 0) &#123;</span><br><span class="line">    x = x + n;</span><br><span class="line">    n = n - 2;</span><br><span class="line">&#125;</span><br><span class="line">x; // 2500</span><br></pre></td></tr></table></figure>
<p> 在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。</p>
<ul>
<li><p>do … while</p>
<p>最后一种循环是do { … } while()循环，它和while循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var n = 0;</span><br><span class="line">do &#123;</span><br><span class="line">    n = n + 1;</span><br><span class="line">&#125; while (n &lt; 100);</span><br><span class="line">n; // 100</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>用do { … } while()循环要小心，循环体会至少执行1次，而for和while循环则可能一次都不执行。</p>
<h4 id="6-Map和Set"><a href="#6-Map和Set" class="headerlink" title="6.Map和Set"></a>6.Map和Set</h4><p>JavaScript的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。</p>
<p>但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。</p>
<ul>
<li><p>Map</p>
<p>Map是一组键值对的结构，具有极快的查找速度。<br>举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;];</span><br><span class="line">var scores = [95, 75, 85];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。</p>
<p>   如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);</span><br><span class="line">m.get(&apos;Michael&apos;); // 95</span><br></pre></td></tr></table></figure>
<p>初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map(); // 空Map</span><br><span class="line">m.set(&apos;Adam&apos;, 67); // 添加新的key-value</span><br><span class="line">m.set(&apos;Bob&apos;, 59);</span><br><span class="line">m.has(&apos;Adam&apos;); // 是否存在key &apos;Adam&apos;: true</span><br><span class="line">m.get(&apos;Adam&apos;); // 67</span><br><span class="line">m.delete(&apos;Adam&apos;); // 删除key &apos;Adam&apos;</span><br><span class="line">m.get(&apos;Adam&apos;); // undefined</span><br></pre></td></tr></table></figure>
<p>   由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map();</span><br><span class="line">m.set(&apos;Adam&apos;, 67);</span><br><span class="line">m.set(&apos;Adam&apos;, 88);</span><br><span class="line">m.get(&apos;Adam&apos;); // 88</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Set</p>
<p>Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。</p>
<p>要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s1 = new Set(); // 空Set</span><br><span class="line">var s2 = new Set([1, 2, 3]); // 含1, 2, 3</span><br></pre></td></tr></table></figure>
<p>重复元素在Set中自动被过滤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s = new Set([1, 2, 3, 3, &apos;3&apos;]);</span><br><span class="line">s; // Set &#123;1, 2, 3, &quot;3&quot;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意数字3和字符串’3’是不同的元素。<br>通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.add(4);</span><br><span class="line">s; // Set &#123;1, 2, 3, 4&#125;</span><br><span class="line">s.add(4);</span><br><span class="line">s; // 仍然是 Set &#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure>
<p>通过delete(key)方法可以删除元素：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = new Set([1, 2, 3]);</span><br><span class="line">s; // Set &#123;1, 2, 3&#125;</span><br><span class="line">s.delete(3);</span><br><span class="line">s; // Set &#123;1, 2&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-iterable"><a href="#7-iterable" class="headerlink" title="7.iterable"></a>7.iterable</h4><p>遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。</p>
<p>具有iterable类型的集合可以通过新的for … of循环来遍历。<br>用for … of循环遍历集合，用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</span><br><span class="line">var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]);</span><br><span class="line">var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]);</span><br><span class="line">for (var x of a) &#123; // 遍历Array</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">for (var x of s) &#123; // 遍历Set</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">for (var x of m) &#123; // 遍历Map</span><br><span class="line">    console.log(x[0] + &apos;=&apos; + x[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能会有疑问，for … of循环和for … in循环有何区别？</p>
<p>for … in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。</p>
<p>当我们手动给Array对象添加了额外的属性后，for … in循环将带来意想不到的意外效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</span><br><span class="line">a.name = &apos;Hello&apos;;</span><br><span class="line">for (var x in a) &#123;</span><br><span class="line">    console.log(x); // &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;name&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for … in循环将把<strong>name</strong>包括在内，但Array的<strong>length</strong>属性却不包括在内。</p>
<p>for … of循环则完全修复了这些问题，它<strong>只循环集合本身的元素</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</span><br><span class="line">a.name = &apos;Hello&apos;;</span><br><span class="line">for (var x of a) &#123;</span><br><span class="line">    console.log(x); // &apos;A&apos;, &apos;B&apos;, &apos;C&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是为什么要引入新的for … of循环。</p>
<p>然而，更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例：</p>
<p>注意，forEach()方法是ES5.1标准引入的，你需要测试浏览器是否支持。</p>
<p>Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]);</span><br><span class="line">s.forEach(function (element, sameElement, set) &#123;</span><br><span class="line">    console.log(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Map的回调函数参数依次为value、key和map本身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]);</span><br><span class="line">m.forEach(function (value, key, map) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得Array的element：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</span><br><span class="line">a.forEach(function (element) &#123;</span><br><span class="line">    console.log(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/进击的前端/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/gaojihealth2.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高济无线团队">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/进击的前端/" itemprop="url">进击的前端HTML基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T15:28:39+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/03/14/进击的前端/" class="leancloud_visitors" data-flag-title="进击的前端HTML基础">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><h5 id="1-HTML的历史"><a href="#1-HTML的历史" class="headerlink" title="1. HTML的历史"></a>1. HTML的历史</h5><p>HTML 全称  Hypertext Markup Language (超文本标记语言)</p>
<p>1991 年，Tim Berners-Lee编写了一份叫做“HTML 标签”得文档，内里包括了大约20个用来标记网页得 HTML标签</p>
<h5 id="2-开发工具"><a href="#2-开发工具" class="headerlink" title="2. 开发工具"></a>2. 开发工具</h5><ul>
<li>推荐工具：VSCode<br><a href="https://code.visualstudio.com" target="_blank" rel="noopener">下载地址</a></li>
<li>如何安装插件：<br>点击左边栏的正方形按钮，搜索框搜索安装相关按钮</li>
<li>常用插件推进:</li>
</ul>
<table>
<thead>
<tr>
<th>插件名称</th>
<th>使用用途</th>
</tr>
</thead>
<tbody>
<tr>
<td> Markdown Preview Enhanced</td>
<td>vscode 直接编写预览markdow 文档</td>
</tr>
<tr>
<td> open in browser</td>
<td>鼠标右键使用 Open Browse 打开浏览器</td>
</tr>
<tr>
<td> HTML Snippets</td>
<td>H5代码片段以及提示</td>
</tr>
<tr>
<td> HTML CSS Support</td>
<td>写 class 智能提示当前项目所支持的样式</td>
</tr>
<tr>
<td> ESLint</td>
<td>JavaScript 代码检查工具</td>
</tr>
<tr>
<td> Debugger for Chrome</td>
<td>vscode 映射 chrome 的 debug功能</td>
</tr>
<tr>
<td> Color Info</td>
<td>颜色指示器</td>
</tr>
</tbody>
</table>
<p></p>
<h5 id="3-常用标签及属性"><a href="#3-常用标签及属性" class="headerlink" title="3. 常用标签及属性"></a>3. 常用标签及属性</h5><p>meta 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;keyword&quot; content=&quot;iPhone&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>title<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;网页标题&lt;/title&gt;</span><br></pre></td></tr></table></figure></p>
<p>body 显示内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//设置背景颜色</span><br><span class="line">&lt;body bgcolor=&quot;#000000&quot;&gt;</span><br><span class="line"></span><br><span class="line">//设置背景图片</span><br><span class="line">&lt;body background=&quot;xx.png&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>link 加载cess样式文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;main.css&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>h header 标题标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;这是标题 1&lt;/h1&gt; </span><br><span class="line">&lt;h2&gt;这是标题 2&lt;/h2&gt; </span><br><span class="line">&lt;h3&gt;这是标题 3&lt;/h3&gt; </span><br><span class="line">&lt;h4&gt;这是标题 4&lt;/h4&gt; </span><br><span class="line">&lt;h5&gt;这是标题 5&lt;/h5&gt; </span><br><span class="line">&lt;h6&gt;这是标题 6&lt;/h6&gt;</span><br></pre></td></tr></table></figure></p>
<p>p paragraph 段落标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt; </span><br><span class="line">    this is paragraph</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>
<p>a anchor 锚点 标签 href打开一个指定链接 target=”_blank” 新开页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//超链接</span><br><span class="line">&lt;a href=&quot;https://baike.baidu.com/item/大闹天竺/16966722?fr=aladdin&quot; target=&quot;_blank&quot;&gt;大闹天竺 &lt;/a&gt;</span><br><span class="line"></span><br><span class="line">target：</span><br><span class="line">1：_blank 代表在新窗口中打开页面的链接地址；</span><br><span class="line">2：_self 代表在自身窗口打开页面链接，默认为self；</span><br><span class="line">3：_parent 代表是在父窗口中打开此网页；</span><br><span class="line">4：_top 代表的是在整个窗口中打开此网页，测试的效果与self相同；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//锚点  作用</span><br><span class="line">&lt;div id = &quot;one&quot;&gt;</span><br><span class="line">    第一章内容</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;#one&quot;&gt;第一章&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">//拨打电话</span><br><span class="line">&lt;a href=&quot;tel:13511111111&quot; class=&quot;call&quot;&gt;拨打客服电话&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">//发邮件</span><br><span class="line">&lt;a href=&quot;mailto:邮件接收人&quot;&gt;发送邮件&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">//协议限定符</span><br><span class="line">&lt;a href=&quot;javascript:alert(&apos;测试&apos;)&quot;&gt;测试&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<p>span 标签被用来组合文档中的行内元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;范围 &lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p>div  元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  可定义文档中的分区或节（division/section）</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>strong 强调文本加粗 em emphasized 斜体 强调文本重要性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;strong&gt;</span><br><span class="line">    &lt;em&gt;</span><br><span class="line">    hello world</span><br><span class="line">    &lt;/em&gt;</span><br><span class="line">&lt;/strong&gt;</span><br></pre></td></tr></table></figure></p>
<p>small 小号字体效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;春眠不觉晓 &lt;small&gt;(孟浩然)&lt;/small&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>
<p>del 标签 文本在中间有线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &lt;del&gt;</span><br><span class="line">    被删除了</span><br><span class="line">&lt;/del&gt;</span><br></pre></td></tr></table></figure></p>
<p>footer  页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer&gt;</span><br><span class="line">    &lt;p&gt;Posted by: W3School&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Contact information: &lt;a href=&quot;mailto:someone@example.com&quot;&gt;someone@example.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line">&lt;/footer&gt;</span><br></pre></td></tr></table></figure></p>
<p>img image 图片标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;soruce.png&quot; width=&quot;100px&quot; height=&quot;100px&quot; alt=&quot;图片出问题了&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>ol order list 有序列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol type=&quot;a&quot; reversed=&quot;reversed&quot;&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">          头脑法人</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">          &lt;a href=&quot;https://baike.baidu.com/item/大闹天竺/16966722?fr=aladdin&quot;&gt;大闹天竺 &lt;/a&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">  &lt;/ol&gt;</span><br></pre></td></tr></table></figure></p>
<p>unorder 无序列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">          今日头条</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">          网易</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>
<p>table 列表 tr table row | td table dataSource<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            苹果</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            鸭梨</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            香蕉</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            馒头</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> &lt;form  method=&quot;GET&quot; action=&quot;https://www.baidu.com&quot;&gt;</span><br><span class="line">        姓名 &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;请输入姓名&quot;/&gt;</span><br><span class="line">         &lt;input type=&quot;submit&quot;/&gt;</span><br><span class="line"> &lt;/form&gt;</span><br><span class="line"></span><br><span class="line">input  type 类型</span><br><span class="line">submit 提交表单</span><br><span class="line">password 密码</span><br><span class="line">checkbox 复选框</span><br><span class="line">radio 单选框</span><br><span class="line">button 按钮</span><br><span class="line">简单的下拉列表</span><br><span class="line">&lt;form&gt;</span><br><span class="line">&lt;select name=&quot;cars&quot;&gt;</span><br><span class="line">&lt;option value=&quot;volvo&quot;&gt;Volvo&lt;/option&gt;</span><br><span class="line">&lt;option value=&quot;saab&quot;&gt;Saab&lt;/option&gt;</span><br><span class="line">&lt;option value=&quot;fiat&quot;&gt;Fiat&lt;/option&gt;</span><br><span class="line">&lt;option value=&quot;audi&quot;&gt;Audi&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>更多标签查看 <a href="http://www.w3school.com.cn/tags/index.asp" target="_blank" rel="noopener">HTML参考手册</a></p>
<p>编辑 : Allen</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/01/Hexo-多端协同/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/gaojihealth2.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高济无线团队">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/01/Hexo-多端协同/" itemprop="url">《Hexo 多端协同文档》</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-01T13:42:37+08:00">
                2019-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/文档/" itemprop="url" rel="index">
                    <span itemprop="name">文档</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/02/01/Hexo-多端协同/" class="leancloud_visitors" data-flag-title="《Hexo 多端协同文档》">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cat ~/.ssh/id_rsa.pub //copy公钥添加到github 上</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> -b Hexo  git@github.com:gjhealth/gjhealth.github.io.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> gjhealth.github.io/Hexo</span><br><span class="line"></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">hexo --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<h3 id="编写博客"><a href="#编写博客" class="headerlink" title="编写博客"></a>编写博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line">hexo new <span class="string">"hello world"</span> //创建一篇博客,markdown 在/Hexo/<span class="built_in">source</span>/_posts 路径下</span><br><span class="line"></span><br><span class="line">hexo s //本地预览</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">"发布博客"</span></span><br><span class="line"></span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line">hexo d -g //发布</span><br><span class="line"></span><br><span class="line">//如果没有更新可以先celan 再hexo d 。浏览器会有缓存，可以清除下缓存在看下是否更新。</span><br><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p> 编辑 : Allen</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/01/hello-world/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/gaojihealth2.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高济无线团队">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/01/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-01T13:35:54+08:00">
                2019-02-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/02/01/hello-world/" class="leancloud_visitors" data-flag-title="Hello World">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/gaojihealth2.png" alt="">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                推荐阅读
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://react.docschina.org" title="React" target="_blank">React</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://reactnative.cn" title="ReactNative" target="_blank">ReactNative</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>

  
</div>












<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共31.3k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    

    

  




	





  














  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("X5j8i5CpYBCrE1nWeTUwCR62-gzGzoHsz", "k5eGxqBTWtVljnqIXHs95twI");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
